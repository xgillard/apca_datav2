//! This module provides an easy access to historical market data API offered by Alpaca.
//! 
//! # Historical Data
//! Alpaca Data API v2 provides three types of historical data: trades, quotes 
//! and bars.
//! 
//! ## Common behavior
//! Alpaca Data API v2 provides historical data through multiple endpoints. 
//! These endpoints have the same URL prefix (omitted from now on):
//! `https://data.alpaca.markets/v2`
//! 
//! This URL is the same for both subscription plans but users with Free 
//! subscription will receive an error when trying to access data that is too 
//! recent.
//! 
//! ### Authentication 
//! The authentication is done the same way as with the Trading 
//! API, simply set the following HTTP headers:
//! * `APCA-API-KEY-ID`
//! * `APCA-API-SECRET-KEY`
//! 
//! ### Limiting
//! Use the limit query parameter. The value should be in the range 1 - 10000 
//! (endpoints included) with 1000 being the default if unspecified.
//! 
//! ### Paging
//! To support querying long timespans continuously we support paging in our 
//! API. If the result you have received contains a next_page_token that is not 
//! null there may be more data available in the timeframe you have chosen. 
//! Include the token you have received as the page_token query parameter for 
//! the next request you make while leaving the other parameters unchanged to 
//! continue where the previous response left off.
//! 
//! ### Ordering
//! The results are ordered in ascending order by time.
//! 
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant 
//! timestamps. These correspond to when a trade was executed or a quote was 
//! generated. As these timestamps are generated by independent market 
//! participants, not the SIP, there is no requirement that the participant used 
//! a synchronized clock or nanosecond resolution. In certain cases due to 
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote 
//! has been reported) will appear before the participant timestamp. 
//! Additionally, though SIP timestampâ€™s have nanosecond resolution, the 
//! participant timestamps may have broader resolution such as milliseconds 
//! or seconds.

use std::{pin::Pin, task::Poll};

use chrono::{DateTime, Utc};
use futures::{Future, FutureExt, Stream};
use reqwest::RequestBuilder;

use crate::{data::{AuthData, BarData, MultiBars, MultiQuotes, MultiTrades, QuoteData, SingleQuote, SingleTrade, TimeFrame, TradeData}, errors::Error};

/// Base URL to access historical data
pub const BASE_URL: &str = "https://data.alpaca.markets/v2";

/// Path to access historical trades
pub const TRADES: &str = "/v2/stocks/{symbol}/trades";
/// Latest trade path
pub const LATEST_TRADE: &str = "/v2/stocks/{symbol}/trades/latest";
/// Path to access the historical quotes (NBBO)
pub const QUOTES: &str = "/v2/stocks/{symbol}/quotes";
/// Path to access the latest historical quote (NBBO)
pub const LATEST_QUOTE: &str = "/v2/stocks/{symbol}/quotes/latest";
/// Path to access the historical bars (OHLC)
pub const BARS: &str = "/v2/stocks/{symbol}/bars";

/// Header used to send the key-id authentication
pub const APCA_API_KEY_ID: &str = "APCA-API-KEY-ID";
/// Header used to send the secret-key for authentication
pub const APCA_API_SECRET_KEY: &str = "APCA-API-SECRET-KEY";


pub struct Client {
    auth:   AuthData,
    client: reqwest::Client,
}
impl Client {
    pub fn new(auth: AuthData) -> Self {
        Self {auth, client: reqwest::Client::new()}
    }
    fn get_authenticated(&self, url: &str) -> RequestBuilder {
        self.client.get(url)
            .header(APCA_API_KEY_ID,     &self.auth.key)
            .header(APCA_API_SECRET_KEY, &self.auth.secret)        
    }

    /// This stream returns the desired trades history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn trades<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>) -> TradesHistoryStream<'a> {
        TradesHistoryStream {
            client: self,
            symbol,
            start, end, 
            limit,
            data: vec![],
            fut: Some(Box::pin(
                self.trades_paged(symbol, start, end, limit, None)
            ))
        }
    }
    /// This stream returns the desired quotes history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn quotes<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>) -> QuotesHistoryStream<'a> {
        QuotesHistoryStream {
            client: self,
            symbol,
            start, end, 
            limit,
            data: vec![],
            fut: Some(Box::pin(
                self.quotes_paged(symbol, start, end, limit, None)
            ))
        }
    }
    /// This stream returns the desired trades history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn bars<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, timeframe: TimeFrame ,limit: Option<usize>) -> BarsHistoryStream<'a> {
        BarsHistoryStream {
            client: self,
            symbol,
            start, end, 
            timeframe, 
            limit,
            data: vec![],
            fut: Some(Box::pin(
                self.bars_paged(symbol, start, end, timeframe, limit, None)
            ))
        }
    }

    /// This endpoint returns trade historical data for the requested security
    pub async fn trades_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>, page_token: Option<String>) -> Result<MultiTrades, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/trades", symbol=symbol);
        let mut query = vec![
            ("start", start.to_rfc3339()),
            ("end",   end.to_rfc3339()),
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await?
                .json::<MultiTrades>().await?;
        Ok(rsp)
    }
    /// This endpoint returns latest trade for the requested security.
    pub async fn latest_trade(&self, symbol: &str) -> Result<SingleTrade, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/trades/latest", symbol=symbol);
        let rsp = self.get_authenticated(&url)
                .send().await?
                .json::<SingleTrade>().await?;
        Ok(rsp)
    }
    /// This endpoint returns quote (NBBO) historical data for the requested security.
    pub async fn quotes_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>, page_token: Option<String>) -> Result<MultiQuotes, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/quotes", symbol=symbol);
        let mut query = vec![
            ("start", start.to_rfc3339()),
            ("end",   end.to_rfc3339()),
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await?
                .json::<MultiQuotes>().await?;
        Ok(rsp)
    }
    /// This endpoint returns latest quote for the requested security.
    pub async fn latest_quote(&self, symbol: &str) -> Result<SingleQuote, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/quotes/latest", symbol=symbol);
        let rsp = self.get_authenticated(&url)
                .send().await?
                .json::<SingleQuote>().await?;
        Ok(rsp)
    }
    /// This endpoint returns aggregate historical data for the requested security.
    pub async fn bars_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, timeframe: TimeFrame ,limit: Option<usize>, page_token: Option<String>) -> Result<MultiBars, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/bars", symbol=symbol);
        let mut query = vec![
            ("start",     start.to_rfc3339()),
            ("end",       end.to_rfc3339()),
            ("timeframe", timeframe.to_string())
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await?
                .json::<MultiBars>().await?;
        Ok(rsp)
    }
}

/******************************************************************************
 ******************************************************************************
 ******************************************************************************/
 
// TODO: If anybody ever reviews this portion of code; is there any better/more
//       idomatic way to accomplish this ?

/// This stream returns the desired trades history going through the several 
/// "pages" of the history asynchoronously; upon request.
pub struct TradesHistoryStream<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    limit: Option<usize>, 

    data: Vec<TradeData>,
    fut : Option<Pin<Box<dyn Future<Output=Result<MultiTrades, Error>> + 'a >>>,
}

impl <'a> Stream for TradesHistoryStream<'a> {
    type Item = TradeData;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Option<Self::Item>> {
        let data = self.data.pop();
        if data.is_some() {
            return Poll::Ready(data);
        } else {
            if let Some(fut) = self.fut.as_mut() {
                return match fut.poll_unpin(cx) {
                    std::task::Poll::Pending => std::task::Poll::Pending,
                    std::task::Poll::Ready(data) => {
                        let multi = data.unwrap();
                        
                        if multi.token.is_some() {
                            self.fut = Some(Box::pin(self.client.trades_paged(
                            self.symbol, 
                            self.start, 
                            self.end, 
                            self.limit, 
                            multi.token)));
                        } else {
                            self.fut = None;
                        }
                        self.data = multi.trades;
                        self.data.reverse();

                        std::task::Poll::Ready(self.data.pop())
                    }
                };
            } else {
                return Poll::Ready(None);
            }
        }
    }
}

/// This stream returns the desired quotes history going through the several 
/// "pages" of the history asynchoronously; upon request.
pub struct QuotesHistoryStream<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    limit: Option<usize>, 

    data: Vec<QuoteData>,
    fut : Option<Pin<Box<dyn Future<Output=Result<MultiQuotes, Error>> + 'a >>>,
}

impl <'a> Stream for QuotesHistoryStream<'a> {
    type Item = QuoteData;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Option<Self::Item>> {
        let data = self.data.pop();
        if data.is_some() {
            return Poll::Ready(data);
        } else {
            if let Some(fut) = self.fut.as_mut() {
                return match fut.poll_unpin(cx) {
                    std::task::Poll::Pending => std::task::Poll::Pending,
                    std::task::Poll::Ready(data) => {
                        let multi = data.unwrap();
                        
                        if multi.token.is_some() {
                            self.fut = Some(Box::pin(self.client.quotes_paged(
                            self.symbol, 
                            self.start, 
                            self.end, 
                            self.limit, 
                            multi.token)));
                        } else {
                            self.fut = None;
                        }
                        self.data = multi.quotes;
                        self.data.reverse();

                        std::task::Poll::Ready(self.data.pop())
                    }
                };
            } else {
                return Poll::Ready(None);
            }
        }
    }
}

/// This stream returns the desired bars history going through the several 
/// "pages" of the history asynchoronously; upon request.
pub struct BarsHistoryStream<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    timeframe: TimeFrame ,
    limit: Option<usize>, 

    data: Vec<BarData>,
    fut : Option<Pin<Box<dyn Future<Output=Result<MultiBars, Error>> + 'a >>>,
}

impl <'a> Stream for BarsHistoryStream<'a> {
    type Item = BarData;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Option<Self::Item>> {
        let data = self.data.pop();
        if data.is_some() {
            return Poll::Ready(data);
        } else {
            if let Some(fut) = self.fut.as_mut() {
                return match fut.poll_unpin(cx) {
                    std::task::Poll::Pending => std::task::Poll::Pending,
                    std::task::Poll::Ready(data) => {
                        let multibars = data.unwrap();
                        
                        if multibars.token.is_some() {
                            self.fut = Some(Box::pin(self.client.bars_paged(
                            self.symbol, 
                            self.start, 
                            self.end, 
                            self.timeframe, 
                            self.limit, 
                            multibars.token)));
                        } else {
                            self.fut = None;
                        }
                        self.data = multibars.bars;
                        self.data.reverse();

                        std::task::Poll::Ready(self.data.pop())
                    }
                };
            } else {
                return Poll::Ready(None);
            }
        }
    }
}


/******************************************************************************
 ******************************************************************************
 ******************************************************************************/

#[cfg(test)]
mod test {
    use dotenv_codegen::dotenv;
    use chrono::{TimeZone, Utc};
    use futures::StreamExt;

    use crate::{data::{AuthData, MultiBars}, historical::Client};



    #[tokio::test]
    async fn test_bars_stream() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let mut stream = client.bars(
            "AAPL", 
            Utc.ymd(2021, 08, 01).and_hms(0, 0, 0),
            Utc.ymd(2021, 08, 15).and_hms(0, 0, 0),
            crate::data::TimeFrame::Day,
            Some(3)
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }

    #[tokio::test]
    async fn test_req() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        //println!("TRADE {:?}", client.latest_trade("AAPL").await?);
        //println!("QUOTE {:?}", client.latest_quote("AAPL").await?);
        println!("BAR   {:?}", client.bars_paged(
            "AAPL", 
            Utc.ymd(2021, 08, 01).and_hms(0, 0, 0),
            Utc.ymd(2021, 08, 09).and_hms(0, 0, 0),
            crate::data::TimeFrame::Day,
            Some(100),
            None
        ).await?);
        Ok(())
    }

    #[test]
    fn bar() {
        let txt = r#"{
            "bars":[
                {"t":"2021-08-02T04:00:00Z",
                 "o":146.36,
                 "h":146.95,
                 "l":145.25,
                 "c":145.52,
                 "v":62745328,
                 "n":456711,
                 "vw":145.856668
                },
                {"t":"2021-08-03T04:00:00Z",
                 "o":145.81,
                 "h":148.045,
                 "l":145.18,
                 "c":147.36,
                 "v":64536401,
                 "n":460706,
                 "vw":146.770321
                }],
            "symbol":"AAPL",
            "next_page_token":"QUFQTHxEfDIwMjEtMDgtMDNUMDQ6MDA6MDAuMDAwMDAwMDAwWg=="
        }"#;
        let parsed = serde_json::from_str::<MultiBars>(txt).unwrap();
        println!("{:?}", parsed)
    }
}