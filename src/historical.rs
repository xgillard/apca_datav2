//! This module provides an easy access to historical market data API offered by Alpaca.
//! 
//! # Historical Data
//! Alpaca Data API v2 provides three types of historical data: trades, quotes 
//! and bars.
//! 
//! ## Common behavior
//! Alpaca Data API v2 provides historical data through multiple endpoints. 
//! These endpoints have the same URL prefix (omitted from now on):
//! `https://data.alpaca.markets/v2`
//! 
//! This URL is the same for both subscription plans but users with Free 
//! subscription will receive an error when trying to access data that is too 
//! recent.
//! 
//! ### Authentication 
//! The authentication is done the same way as with the Trading 
//! API, simply set the following HTTP headers:
//! * `APCA-API-KEY-ID`
//! * `APCA-API-SECRET-KEY`
//! 
//! ### Limiting
//! Use the limit query parameter. The value should be in the range 1 - 10000 
//! (endpoints included) with 1000 being the default if unspecified.
//! 
//! ### Paging
//! To support querying long timespans continuously we support paging in our 
//! API. If the result you have received contains a next_page_token that is not 
//! null there may be more data available in the timeframe you have chosen. 
//! Include the token you have received as the page_token query parameter for 
//! the next request you make while leaving the other parameters unchanged to 
//! continue where the previous response left off.
//! 
//! ### Ordering
//! The results are ordered in ascending order by time.
//! 
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant 
//! timestamps. These correspond to when a trade was executed or a quote was 
//! generated. As these timestamps are generated by independent market 
//! participants, not the SIP, there is no requirement that the participant used 
//! a synchronized clock or nanosecond resolution. In certain cases due to 
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote 
//! has been reported) will appear before the participant timestamp. 
//! Additionally, though SIP timestampâ€™s have nanosecond resolution, the 
//! participant timestamps may have broader resolution such as milliseconds 
//! or seconds.

use std::{collections::HashMap, fmt::Display, pin::Pin};

use chrono::{DateTime, Utc};
use futures::{Future, Stream};
use itertools::Itertools;
use serde::{Serialize, Deserialize};
use crate::{entities::{BarData, QuoteData, TradeData}, errors::{Error, maybe_convert_to_hist_error, status_code_to_hist_error}, rest::{Client, FetchNextPage, Paged, PagedStream}};

/// Base URL to access historical data
pub const BASE_URL: &str = "https://data.alpaca.markets/v2";

/// Path to access historical trades
pub const TRADES: &str = "/v2/stocks/{symbol}/trades";
/// Latest trade path
pub const LATEST_TRADE: &str = "/v2/stocks/{symbol}/trades/latest";
/// Path to access the historical quotes (NBBO)
pub const QUOTES: &str = "/v2/stocks/{symbol}/quotes";
/// Path to access the latest historical quote (NBBO)
pub const LATEST_QUOTE: &str = "/v2/stocks/{symbol}/quotes/latest";
/// Path to access the historical bars (OHLC)
pub const BARS: &str = "/v2/stocks/{symbol}/bars";

impl Client {
    /// This stream returns the desired trades history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn trades<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>) -> impl Stream<Item=TradeData> + 'a {
        PagedStream::new(FetchNextTrades {
            client: self,
            symbol,
            start, end,
            limit
        })
    }
    /// This stream returns the desired quotes history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn quotes<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>) -> impl Stream<Item=QuoteData> + 'a {
        PagedStream::new(FetchNextQuotes {
            client: self,
            symbol,
            start, end,
            limit
        })
    }
    /// This stream returns the desired trades history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn bars<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, timeframe: TimeFrame ,limit: Option<usize>) -> impl Stream<Item=BarData> + 'a {
        PagedStream::new(FetchNextBars {
            client: self,
            symbol,
            start, end,
            timeframe,
            limit
        })
    }

    /// This endpoint returns trade historical data for the requested security
    pub async fn trades_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>, page_token: Option<String>) -> Result<MultiTrades, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/trades", symbol=symbol);
        let mut query = vec![
            ("start", start.to_rfc3339()),
            ("end",   end.to_rfc3339()),
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp = self.get_authenticated(&url)
                .query(&query)
                .send().await
                .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// This endpoint returns latest trade for the requested security.
    pub async fn latest_trade(&self, symbol: &str) -> Result<SingleTrade, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/trades/latest", symbol=symbol);
        let rsp = self.get_authenticated(&url)
                .send().await
                .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// This endpoint returns quote (NBBO) historical data for the requested security.
    pub async fn quotes_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>, page_token: Option<String>) -> Result<MultiQuotes, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/quotes", symbol=symbol);
        let mut query = vec![
            ("start", start.to_rfc3339()),
            ("end",   end.to_rfc3339()),
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await
                .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// This endpoint returns latest quote for the requested security.
    pub async fn latest_quote(&self, symbol: &str) -> Result<SingleQuote, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/quotes/latest", symbol=symbol);
        let rsp = self.get_authenticated(&url)
                .send().await
                .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// This endpoint returns aggregate historical data for the requested security.
    pub async fn bars_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, timeframe: TimeFrame ,limit: Option<usize>, page_token: Option<String>) -> Result<MultiBars, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/bars", symbol=symbol);
        let mut query = vec![
            ("start",     start.to_rfc3339()),
            ("end",       end.to_rfc3339()),
            ("timeframe", timeframe.to_string())
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await
                .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// The Snapshot API for one ticker provides the latest trade, latest quote, 
    /// minute bar daily bar and previous daily bar data for a given ticker symbol.
    pub async fn snapshot(&self, symbol: &str) -> Result<SingleSnapshot, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/snapshot", symbol=symbol);
        let rsp = self.get_authenticated(&url)
            .send().await
            .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// The Snapshot API for multiple tickers provides the latest trade, 
    /// latest quote, minute bar daily bar and previous daily bar data for 
    /// the given ticker symbols.
    pub async fn snapshots_multi(&self, symbols: &str) -> Result<HashMap<String, SnapshotData>, Error> {
        let url = "https://data.alpaca.markets/v2/stocks/snapshots";
        let rsp = self.get_authenticated(url)
            .query(&[("symbols", symbols)])
            .send().await
            .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
    /// The Snapshot API for multiple tickers provides the latest trade, 
    /// latest quote, minute bar daily bar and previous daily bar data for 
    /// the given ticker symbols.
    pub async fn snapshots_multi_vec(&self, symbols: &[&str]) -> Result<HashMap<String, SnapshotData>, Error> {
        let url = "https://data.alpaca.markets/v2/stocks/snapshots";
        let symbols = symbols.iter().join(",");
        let rsp = self.get_authenticated(url)
            .query(&[("symbols", symbols)])
            .send().await
            .map_err(maybe_convert_to_hist_error)?;

        status_code_to_hist_error(rsp).await
    }
}

/******************************************************************************
 * HISTORY DATA POINTS ********************************************************
 ******************************************************************************/

 /// Timeframe for the aggregation. Available values are: 1Min, 1Hour, 1Day.
 #[derive(Debug, Clone, Copy, Eq, PartialEq, Hash, Serialize, Deserialize)]
 pub enum TimeFrame {
    #[serde(rename="1Min")]
    Minute, 
    #[serde(rename="1Hour")]
    Hour,
    #[serde(rename="1Day")]
    Day
 }
 impl Display for TimeFrame {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Minute => write!(f, "1Min"),
            Self::Hour   => write!(f, "1Hour"),
            Self::Day    => write!(f, "1Day"),
        }
    }
}

/// A datapoint that holds one single quote
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SingleQuote {
    /// The symbol
    pub symbol: String,
    /// The actual payload
    pub quote  : QuoteData,
}
/// A datapoint that holds one single quote
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiQuotes {
    /// The actual payload
    #[serde(deserialize_with="crate::utils::null_as_emptyvec")]
    pub quotes : Vec<QuoteData>,
    /// The symbol
    pub symbol: String,
    #[serde(rename="next_page_token")]
    pub token : Option<String>,
}
/// A datapoint that holds one single trade
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SingleTrade {
    /// The symbol
    pub symbol: String,
    /// The actual payload
    pub trade  : TradeData,
}
/// A datapoint that holds one single trade
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiTrades {
    /// The actual payload
    #[serde(deserialize_with="crate::utils::null_as_emptyvec")]
    pub trades : Vec<TradeData>,
    /// The symbol
    pub symbol: String,
    #[serde(rename="next_page_token")]
    pub token : Option<String>,
}
/// A datapoint that holds one single bar
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SingleBar {
    /// The actual payload
    pub bar  : BarData,
    /// The symbol
    pub symbol: String,
}
/// A datapoint that holds one single trade
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MultiBars {
    /// The actual payload
    #[serde(deserialize_with="crate::utils::null_as_emptyvec")]
    pub bars  : Vec<BarData>,
    /// The symbol
    pub symbol: String,
    #[serde(rename="next_page_token")]
    pub token : Option<String>,
}

/******************************************************************************
 * SNAPSHOTS ******************************************************************
 ******************************************************************************/

/// The Snapshot API for one ticker provides the latest trade, latest quote, 
/// minute bar daily bar and previous daily bar data for a given ticker symbol.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SnapshotData {
    /// Latest trade object.
    #[serde(rename = "latestTrade")]
    pub latest_trade: TradeData,
    /// Latest quote object
    #[serde(rename = "latestQuote")]
    pub latest_quote: QuoteData,
    /// Minute bar object.
    #[serde(rename = "minuteBar")]
    pub minute_bar: BarData,
    /// Daily bar object.
    #[serde(rename = "dailyBar")]
    pub daily_bar: BarData,
    /// Previous daily close bar object
    #[serde(rename = "prevDailyBar")]
    pub prev_daily_bar: BarData,
}

/// The Snapshot API for one ticker provides the latest trade, latest quote, 
/// minute bar daily bar and previous daily bar data for a given ticker symbol.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SingleSnapshot {
    /// The symbol
    pub symbol: String, 
    /// The actual payload
    #[serde(flatten)]
    pub data: SnapshotData,
}

/*----------------------------------------------------------------------------*/
/* THE MULTI-* DATA POINTS ARE STRUCTURES THAT EMBODY THE PAGING MECHANISM    */
/*----------------------------------------------------------------------------*/
impl Paged for MultiTrades {
    type Item = TradeData;
    fn split(self) -> (Vec<Self::Item>, Option<String>) {
        (self.trades, self.token)
    }
}
impl Paged for MultiQuotes {
    type Item = QuoteData;
    fn split(self) -> (Vec<Self::Item>, Option<String>) {
        (self.quotes, self.token)
    }
}
impl Paged for MultiBars {
    type Item = BarData;
    fn split(self) -> (Vec<Self::Item>, Option<String>) {
        (self.bars, self.token)
    }
}

/// This structure encapsulates a call to `trades_paged` and yields a future
/// that can be used to asychronously fetch the next trades page
struct FetchNextTrades<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    limit: Option<usize>, 
}
impl <'a> FetchNextPage<'a, MultiTrades> for FetchNextTrades<'a> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box<dyn Future<Output=Result<MultiTrades, Error>> + 'a >> {
        Box::pin(
            self.client.trades_paged(
                self.symbol, self.start, self.end, self.limit, token)
        )
    }
}

/// This structure encapsulates a call to `quotes_paged` and yields a future
/// that can be used to asychronously fetch the next quotes page
struct FetchNextQuotes<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    limit: Option<usize>, 
}
impl <'a> FetchNextPage<'a, MultiQuotes> for FetchNextQuotes<'a> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box<dyn Future<Output=Result<MultiQuotes, Error>> + 'a >> {
        Box::pin(
            self.client.quotes_paged(
                self.symbol, self.start, self.end, self.limit, token)
        )
    }
}

/// This structure encapsulates a call to `bars_paged` and yields a future
/// that can be used to asychronously fetch the next bars page
struct FetchNextBars<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    timeframe: TimeFrame ,
    limit: Option<usize>, 
}
impl <'a> FetchNextPage<'a, MultiBars> for FetchNextBars<'a> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box<dyn Future<Output=Result<MultiBars, Error>> + 'a >> {
        Box::pin(
            self.client.bars_paged(
                self.symbol, self.start, self.end, self.timeframe, self.limit, token)
        )
    }
}

/******************************************************************************
 ******************************************************************************
 ******************************************************************************/

#[cfg(test)]
mod test {
    use dotenv_codegen::dotenv;
    use chrono::{TimeZone, Utc};
    use futures::StreamExt;

    use crate::{historical::MultiBars, rest::Client};

    #[tokio::test]
    async fn test_bars_stream() -> Result<(), anyhow::Error> {
        let client   = Client::paper(
            dotenv!("APCA_KEY_ID").to_string(), 
            dotenv!("APCA_SECRET").to_string() 
        );

        let mut stream = client.bars(
            "AAPL", 
            Utc.ymd(2021,  8,  1).and_hms(0, 0, 0),
            Utc.ymd(2021,  8, 15).and_hms(0, 0, 0),
            crate::historical::TimeFrame::Day,
            Some(3)
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }

    #[tokio::test]
    async fn test_quotes_stream() -> Result<(), anyhow::Error> {
        let client   = Client::paper(
            dotenv!("APCA_KEY_ID").to_string(), 
            dotenv!("APCA_SECRET").to_string() 
        );

        let mut stream = client.quotes(
            "AAPL", 
            Utc.ymd(2021,  8,  2).and_hms(16, 0, 0),
            Utc.ymd(2021,  8,  2).and_hms(16, 3, 0),
            None
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }


    #[tokio::test]
    async fn test_trades_stream() -> Result<(), anyhow::Error> {
        let client   = Client::paper(
            dotenv!("APCA_KEY_ID").to_string(), 
            dotenv!("APCA_SECRET").to_string() 
        );
        
        let mut stream = client.trades(
            "AAPL", 
            Utc.ymd(2021,  8,  1).and_hms(16, 0, 0),
            Utc.ymd(2021,  8,  1).and_hms(16, 5, 0),
            None
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }
    
    #[tokio::test]
    async fn test_snapshot() -> Result<(), anyhow::Error> {
        let client   = Client::paper(
            dotenv!("APCA_KEY_ID").to_string(), 
            dotenv!("APCA_SECRET").to_string() 
        );

        let data = client.snapshot("AAPL").await?;
        println!("{:?}", data);

        Ok(())
    }
    #[tokio::test]
    async fn test_snapshots_multi() -> Result<(), anyhow::Error> {
        let client   = Client::paper(
            dotenv!("APCA_KEY_ID").to_string(), 
            dotenv!("APCA_SECRET").to_string() 
        );

        let data = client.snapshots_multi("AAPL,MSFT,TSM").await?;
        println!("{:?}", data);

        Ok(())
    }
    #[tokio::test]
    async fn test_snapshots_multi_vec() -> Result<(), anyhow::Error> {
        let client   = Client::paper(
            dotenv!("APCA_KEY_ID").to_string(), 
            dotenv!("APCA_SECRET").to_string() 
        );

        let data = client.snapshots_multi_vec(&["AAPL","MSFT","TSM"]).await?;
        println!("{:?}", data);

        Ok(())
    }

    #[test]
    fn bar() {
        let txt = r#"{
            "bars":[
                {"t":"2021-08-02T04:00:00Z",
                 "o":146.36,
                 "h":146.95,
                 "l":145.25,
                 "c":145.52,
                 "v":62745328,
                 "n":456711,
                 "vw":145.856668
                },
                {"t":"2021-08-03T04:00:00Z",
                 "o":145.81,
                 "h":148.045,
                 "l":145.18,
                 "c":147.36,
                 "v":64536401,
                 "n":460706,
                 "vw":146.770321
                }],
            "symbol":"AAPL",
            "next_page_token":"QUFQTHxEfDIwMjEtMDgtMDNUMDQ6MDA6MDAuMDAwMDAwMDAwWg=="
        }"#;
        let parsed = serde_json::from_str::<MultiBars>(txt).unwrap();
        println!("{:?}", parsed)
    }
}