//! This module provides an easy access to historical market data API offered by Alpaca.
//! 
//! # Historical Data
//! Alpaca Data API v2 provides three types of historical data: trades, quotes 
//! and bars.
//! 
//! ## Common behavior
//! Alpaca Data API v2 provides historical data through multiple endpoints. 
//! These endpoints have the same URL prefix (omitted from now on):
//! `https://data.alpaca.markets/v2`
//! 
//! This URL is the same for both subscription plans but users with Free 
//! subscription will receive an error when trying to access data that is too 
//! recent.
//! 
//! ### Authentication 
//! The authentication is done the same way as with the Trading 
//! API, simply set the following HTTP headers:
//! * `APCA-API-KEY-ID`
//! * `APCA-API-SECRET-KEY`
//! 
//! ### Limiting
//! Use the limit query parameter. The value should be in the range 1 - 10000 
//! (endpoints included) with 1000 being the default if unspecified.
//! 
//! ### Paging
//! To support querying long timespans continuously we support paging in our 
//! API. If the result you have received contains a next_page_token that is not 
//! null there may be more data available in the timeframe you have chosen. 
//! Include the token you have received as the page_token query parameter for 
//! the next request you make while leaving the other parameters unchanged to 
//! continue where the previous response left off.
//! 
//! ### Ordering
//! The results are ordered in ascending order by time.
//! 
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant 
//! timestamps. These correspond to when a trade was executed or a quote was 
//! generated. As these timestamps are generated by independent market 
//! participants, not the SIP, there is no requirement that the participant used 
//! a synchronized clock or nanosecond resolution. In certain cases due to 
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote 
//! has been reported) will appear before the participant timestamp. 
//! Additionally, though SIP timestampâ€™s have nanosecond resolution, the 
//! participant timestamps may have broader resolution such as milliseconds 
//! or seconds.

use std::{collections::HashMap, pin::Pin, task::Poll};

use chrono::{DateTime, Utc};
use futures::{Future, FutureExt, Stream};
use itertools::Itertools;
use reqwest::RequestBuilder;

use crate::{data::{AuthData, BarData, MultiBars, MultiQuotes, MultiTrades, QuoteData, SingleQuote, SingleSnapshot, SingleTrade, SnapshotData, TimeFrame, TradeData}, errors::{Error, maybe_convert_to_hist_error}};

/// Base URL to access historical data
pub const BASE_URL: &str = "https://data.alpaca.markets/v2";

/// Path to access historical trades
pub const TRADES: &str = "/v2/stocks/{symbol}/trades";
/// Latest trade path
pub const LATEST_TRADE: &str = "/v2/stocks/{symbol}/trades/latest";
/// Path to access the historical quotes (NBBO)
pub const QUOTES: &str = "/v2/stocks/{symbol}/quotes";
/// Path to access the latest historical quote (NBBO)
pub const LATEST_QUOTE: &str = "/v2/stocks/{symbol}/quotes/latest";
/// Path to access the historical bars (OHLC)
pub const BARS: &str = "/v2/stocks/{symbol}/bars";

/// Header used to send the key-id authentication
pub const APCA_API_KEY_ID: &str = "APCA-API-KEY-ID";
/// Header used to send the secret-key for authentication
pub const APCA_API_SECRET_KEY: &str = "APCA-API-SECRET-KEY";


pub struct Client {
    auth:   AuthData,
    client: reqwest::Client,
}
impl Client {
    pub fn new(auth: AuthData) -> Self {
        Self {auth, client: reqwest::Client::new()}
    }
    fn get_authenticated(&self, url: &str) -> RequestBuilder {
        self.client.get(url)
            .header(APCA_API_KEY_ID,     &self.auth.key)
            .header(APCA_API_SECRET_KEY, &self.auth.secret)        
    }

    /// This stream returns the desired trades history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn trades<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>) -> impl Stream<Item=TradeData> + 'a {
        PagedStream::new(FetchNextTrades {
            client: self,
            symbol,
            start, end,
            limit
        })
    }
    /// This stream returns the desired quotes history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn quotes<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>) -> impl Stream<Item=QuoteData> + 'a {
        PagedStream::new(FetchNextQuotes {
            client: self,
            symbol,
            start, end,
            limit
        })
    }
    /// This stream returns the desired trades history going through the several 
    /// "pages" of the history asynchoronously; upon request.
    pub fn bars<'a>(&'a self, symbol: &'a str, start: DateTime<Utc>, end: DateTime<Utc>, timeframe: TimeFrame ,limit: Option<usize>) -> impl Stream<Item=BarData> + 'a {
        PagedStream::new(FetchNextBars {
            client: self,
            symbol,
            start, end,
            timeframe,
            limit
        })
    }

    /// This endpoint returns trade historical data for the requested security
    pub async fn trades_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>, page_token: Option<String>) -> Result<MultiTrades, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/trades", symbol=symbol);
        let mut query = vec![
            ("start", start.to_rfc3339()),
            ("end",   end.to_rfc3339()),
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp = self.get_authenticated(&url)
                .query(&query)
                .send().await
                .map_err(|e| maybe_convert_to_hist_error(e))?
                .json::<MultiTrades>().await?;
        Ok(rsp)
    }
    /// This endpoint returns latest trade for the requested security.
    pub async fn latest_trade(&self, symbol: &str) -> Result<SingleTrade, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/trades/latest", symbol=symbol);
        let rsp = self.get_authenticated(&url)
                .send().await
                .map_err(|e| maybe_convert_to_hist_error(e))?
                .json::<SingleTrade>().await?;
        Ok(rsp)
    }
    /// This endpoint returns quote (NBBO) historical data for the requested security.
    pub async fn quotes_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, limit: Option<usize>, page_token: Option<String>) -> Result<MultiQuotes, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/quotes", symbol=symbol);
        let mut query = vec![
            ("start", start.to_rfc3339()),
            ("end",   end.to_rfc3339()),
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await
                .map_err(|e| maybe_convert_to_hist_error(e))?
                .json::<MultiQuotes>().await?;
        Ok(rsp)
    }
    /// This endpoint returns latest quote for the requested security.
    pub async fn latest_quote(&self, symbol: &str) -> Result<SingleQuote, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/quotes/latest", symbol=symbol);
        let rsp = self.get_authenticated(&url)
                .send().await
                .map_err(|e| maybe_convert_to_hist_error(e))?
                .json::<SingleQuote>().await?;
        Ok(rsp)
    }
    /// This endpoint returns aggregate historical data for the requested security.
    pub async fn bars_paged(&self, symbol: &str, start: DateTime<Utc>, end: DateTime<Utc>, timeframe: TimeFrame ,limit: Option<usize>, page_token: Option<String>) -> Result<MultiBars, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/bars", symbol=symbol);
        let mut query = vec![
            ("start",     start.to_rfc3339()),
            ("end",       end.to_rfc3339()),
            ("timeframe", timeframe.to_string())
            ];
        if let Some(limit) = limit {
            query.push(("limit", limit.to_string()))
        }
        if let Some(token) = page_token {
            query.push(("page_token", token));
        }
        let rsp   = self.get_authenticated(&url)
                .query(&query)
                .send().await
                .map_err(|e| maybe_convert_to_hist_error(e))?
                .json::<MultiBars>().await?;
        Ok(rsp)
    }
    /// The Snapshot API for one ticker provides the latest trade, latest quote, 
    /// minute bar daily bar and previous daily bar data for a given ticker symbol.
    pub async fn snapshot(&self, symbol: &str) -> Result<SingleSnapshot, Error> {
        let url = format!("https://data.alpaca.markets/v2/stocks/{symbol}/snapshot", symbol=symbol);
        let rsp = self.get_authenticated(&url)
            .send().await
            .map_err(|e| maybe_convert_to_hist_error(e))?
            .json::<SingleSnapshot>().await?;
        Ok(rsp)
    }
    /// The Snapshot API for multiple tickers provides the latest trade, 
    /// latest quote, minute bar daily bar and previous daily bar data for 
    /// the given ticker symbols.
    pub async fn snapshots_multi(&self, symbols: &str) -> Result<HashMap<String, SnapshotData>, Error> {
        let url = "https://data.alpaca.markets/v2/stocks/snapshots";
        let rsp = self.get_authenticated(&url)
            .query(&[("symbols", symbols)])
            .send().await
            .map_err(|e| maybe_convert_to_hist_error(e))?
            .json::<HashMap<String, SnapshotData>>().await?;
        Ok(rsp)
    }
    /// The Snapshot API for multiple tickers provides the latest trade, 
    /// latest quote, minute bar daily bar and previous daily bar data for 
    /// the given ticker symbols.
    pub async fn snapshots_multi_vec(&self, symbols: &[&str]) -> Result<HashMap<String, SnapshotData>, Error> {
        let url = "https://data.alpaca.markets/v2/stocks/snapshots";
        let symbols = symbols.iter().join(",");
        let rsp = self.get_authenticated(&url)
            .query(&[("symbols", symbols)])
            .send().await
            .map_err(|e| maybe_convert_to_hist_error(e))?
            .json::<HashMap<String, SnapshotData>>().await?;
        Ok(rsp)
    }
}

/******************************************************************************
 ******************************************************************************
 ******************************************************************************/
 
// TODO: If anybody ever reviews this portion of code; is there any better/more
//       idomatic way to accomplish this ?

/// This trait denotes a page (aka a chunk) from a paginated list of item.
/// Basically, it gives a convenient way to transparently access the paged 
/// data along with the next page token which needs to be sent to server in 
/// order to fetch the next chunk.
trait Paged {
    type Item;
    /// Splits the page in a data set and an optional next page token
    fn split(self) -> (Vec<Self::Item>, Option<String>);
}
/// This trait basically denotes a factory that creates a future used to fetch
/// the next chunk of data from the server
trait FetchNextPage<'a, T: Paged> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box< dyn Future<Output=Result<T, Error>> + 'a >>;
}

/// A future bound to some given lifetime, returning an Ok(T) or an Error
type FailibleFuture<'a, T> = dyn Future<Output=Result<T, Error>> + 'a;

/// A paged stream is a stream that buffers a chunk of data and transparently 
/// fetches the next page whenever whenever needed.
struct PagedStream<'a, T, F> 
where T: Paged, 
      T::Item: Unpin,
      F: FetchNextPage<'a, T> + Unpin
{
    source: Pin<Box<F>>,
    data  : Vec<T::Item>,
    fut   : Option<Pin<Box< FailibleFuture<'a, T> >>>
}

impl <'a, T, F> PagedStream<'a, T, F> 
where T: Paged, 
      T::Item: Unpin,
      F: FetchNextPage<'a, T> + Unpin
{
    /// Creates a new paged stream from a given source. The first future is
    /// created by passing a None token.
    pub fn new(source: F) -> Self {
        let source = Box::pin(source);
        let fut    = source.as_ref().fetch(None);

        Self {
            source,
            data: vec![],
            fut : Some(fut),
        }
    }
}

impl <'a, T, F> Stream for PagedStream<'a, T, F> 
where T: Paged, 
      T::Item: Unpin,
      F: FetchNextPage<'a, T> + Unpin
{
    type Item = T::Item;

    fn poll_next(mut self: Pin<&mut Self>, cx: &mut std::task::Context<'_>) -> std::task::Poll<Option<Self::Item>> {
        let data = self.data.pop();
        if data.is_some() {
            Poll::Ready(data)
        } else if let Some(fut) = self.fut.as_mut() {
            match fut.poll_unpin(cx) {
                std::task::Poll::Pending => std::task::Poll::Pending,
                std::task::Poll::Ready(data) => {
                    let (data, token) = data.unwrap().split();
                    
                    if token.is_some() {
                        self.fut = Some(self.source.as_ref().fetch(token));
                    } else {
                        self.fut = None;
                    }
                    self.data = data;
                    self.data.reverse();

                    std::task::Poll::Ready(self.data.pop())
                }
            }
        } else {
            Poll::Ready(None)
        }
    }
}
/*----------------------------------------------------------------------------*/
/* THE MULTI-* DATA POINTS ARE STRUCTURES THAT EMBODY THE PAGING MECHANISM    */
/*----------------------------------------------------------------------------*/
impl Paged for MultiTrades {
    type Item = TradeData;
    fn split(self) -> (Vec<Self::Item>, Option<String>) {
        (self.trades, self.token)
    }
}
impl Paged for MultiQuotes {
    type Item = QuoteData;
    fn split(self) -> (Vec<Self::Item>, Option<String>) {
        (self.quotes, self.token)
    }
}
impl Paged for MultiBars {
    type Item = BarData;
    fn split(self) -> (Vec<Self::Item>, Option<String>) {
        (self.bars, self.token)
    }
}

/// This structure encapsulates a call to `trades_paged` and yields a future
/// that can be used to asychronously fetch the next trades page
struct FetchNextTrades<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    limit: Option<usize>, 
}
impl <'a> FetchNextPage<'a, MultiTrades> for FetchNextTrades<'a> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box<dyn Future<Output=Result<MultiTrades, Error>> + 'a >> {
        Box::pin(
            self.client.trades_paged(
                self.symbol, self.start, self.end, self.limit, token)
        )
    }
}

/// This structure encapsulates a call to `quotes_paged` and yields a future
/// that can be used to asychronously fetch the next quotes page
struct FetchNextQuotes<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    limit: Option<usize>, 
}
impl <'a> FetchNextPage<'a, MultiQuotes> for FetchNextQuotes<'a> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box<dyn Future<Output=Result<MultiQuotes, Error>> + 'a >> {
        Box::pin(
            self.client.quotes_paged(
                self.symbol, self.start, self.end, self.limit, token)
        )
    }
}

/// This structure encapsulates a call to `bars_paged` and yields a future
/// that can be used to asychronously fetch the next bars page
struct FetchNextBars<'a> {
    client: &'a Client,
    // params
    symbol: &'a str, 
    start: DateTime<Utc>, 
    end: DateTime<Utc>, 
    timeframe: TimeFrame ,
    limit: Option<usize>, 
}
impl <'a> FetchNextPage<'a, MultiBars> for FetchNextBars<'a> {
    fn fetch(self: Pin<&Self>, token: Option<String>) -> Pin<Box<dyn Future<Output=Result<MultiBars, Error>> + 'a >> {
        Box::pin(
            self.client.bars_paged(
                self.symbol, self.start, self.end, self.timeframe, self.limit, token)
        )
    }
}
/******************************************************************************
 ******************************************************************************
 ******************************************************************************/

#[cfg(test)]
mod test {
    use dotenv_codegen::dotenv;
    use chrono::{TimeZone, Utc};
    use futures::StreamExt;

    use crate::{data::{AuthData, MultiBars}, historical::Client};



    #[tokio::test]
    async fn test_bars_stream() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let mut stream = client.bars(
            "AAPL", 
            Utc.ymd(2021, 08, 01).and_hms(0, 0, 0),
            Utc.ymd(2021, 08, 15).and_hms(0, 0, 0),
            crate::data::TimeFrame::Day,
            Some(3)
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }

    #[tokio::test]
    async fn test_quotes_stream() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let mut stream = client.quotes(
            "AAPL", 
            Utc.ymd(2021, 08, 02).and_hms(16, 0, 0),
            Utc.ymd(2021, 08, 02).and_hms(16, 3, 0),
            None
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }


    #[tokio::test]
    async fn test_trades_stream() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let mut stream = client.trades(
            "AAPL", 
            Utc.ymd(2021, 08, 01).and_hms(16, 0, 0),
            Utc.ymd(2021, 08, 01).and_hms(16, 5, 0),
            None
        );

        while let Some(x) = stream.next().await {
            println!("{:?}", x.timestamp);
        }

        Ok(())
    }
    
    #[tokio::test]
    async fn test_snapshot() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let data = client.snapshot("AAPL").await?;
        println!("{:?}", data);

        Ok(())
    }
    #[tokio::test]
    async fn test_snapshots_multi() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let data = client.snapshots_multi("AAPL,MSFT,TSM").await?;
        println!("{:?}", data);

        Ok(())
    }
    #[tokio::test]
    async fn test_snapshots_multi_vec() -> Result<(), anyhow::Error> {
        let client   = Client::new(AuthData { 
            key: dotenv!("APCA_KEY_ID").to_string(), 
            secret: dotenv!("APCA_SECRET").to_string() 
        });

        let data = client.snapshots_multi_vec(&["AAPL","MSFT","TSM"]).await?;
        println!("{:?}", data);

        Ok(())
    }

    #[test]
    fn bar() {
        let txt = r#"{
            "bars":[
                {"t":"2021-08-02T04:00:00Z",
                 "o":146.36,
                 "h":146.95,
                 "l":145.25,
                 "c":145.52,
                 "v":62745328,
                 "n":456711,
                 "vw":145.856668
                },
                {"t":"2021-08-03T04:00:00Z",
                 "o":145.81,
                 "h":148.045,
                 "l":145.18,
                 "c":147.36,
                 "v":64536401,
                 "n":460706,
                 "vw":146.770321
                }],
            "symbol":"AAPL",
            "next_page_token":"QUFQTHxEfDIwMjEtMDgtMDNUMDQ6MDA6MDAuMDAwMDAwMDAwWg=="
        }"#;
        let parsed = serde_json::from_str::<MultiBars>(txt).unwrap();
        println!("{:?}", parsed)
    }
}