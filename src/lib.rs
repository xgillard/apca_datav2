//! # Real-time data
//! Alpaca Data API v2 provides websocket streaming for trades, quotes and 
//! minute bars. This helps receive the most up to date market information that 
//! could help your trading strategy to act upon certain market movements.
//! 
//! Once a connection is established and you have successfully authenticated 
//! yourself you can subscribe to trades, quotes and minute bars for a 
//! particular symbol or multiple symbols.
//! 
//! ## Subscription plans
//! * **Free plan**:
//!   You can only connect to IEX data source. One concurrent connection is allowed.
//!   Subscription is limited to 30 channels at a time for trades (trades) and 
//!   quotes (quotes). We may support more channels in the future. There is no 
//!   limit for the number of channels with minute bars (bars). Minute bars are 
//!   based on the trades from IEX.
//! 
//! * **Unlimited plan**:
//!   There is no limit for the number of channels at a time for trades, 
//!   quotes and minute bars(trades,quotes and bars). Trades, quotes and mintue 
//!   bars are direct feeds from the CTA (administered by NYSE) and 
//!   UTP (administered by Nasdaq) SIPs.
//! 
//! ## Common behavior
//! To access real-time data use the URL below, substituting `iex` or `sip` to 
//! {source} depending on your subscription.
//! `wss://stream.data.alpaca.markets/v2/{source}`
//! 
//! Attemption to access a data source not available for your subscription will 
//! result in an error during authentication.
//! 
//! ### Message format
//! Every message you receive from the server will be in the format:
//! ```[{"T": "{message_type}", {contents}},...]``` 
//! 
//! Control messages (i.e. where "T" is error, success or subscription) always 
//! arrive in arrays of size one to make their processing easier.
//! 
//! Data points however may arrive in arrays that have a length that is greater 
//! than one. This is to facilitate clients whose connection is not fast enough 
//! to handle data points sent one by one. Our server buffers the outgoing 
//! messages but slow clients may get disconnected if their buffer becomes full.
//! 
//! ### Encoding and compression
//! Messages over the websocket are in encoded as clear text.
//! To reduce bandwidth requirements we have implemented compression as per 
//! RFC-7692. Our SDKs handle this for you so in most cases you won’t have to 
//! implement anything yourself.
//! 
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant 
//! timestamps. These correspond to when a trade was executed or a quote was 
//! generated. As these timestamps are generated by independent market 
//! participants, not the SIP, there is no requirement that the participant 
//! used a synchronized clock or nanosecond resolution. In certain cases due to 
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote 
//! has been reported) will appear before the participant timestamp. 
//! Additionally, though SIP timestamp’s have nanosecond resolution, the 
//! participant timestamps may have broader resolution such as milliseconds or 
//! seconds.

extern crate serde;

use chrono::{DateTime, Utc};
use derive_builder::Builder;
use futures::{SinkExt, StreamExt, stream::{SplitSink, SplitStream}};
use serde::{Serialize, Deserialize};
use serde_repr::{Serialize_repr, Deserialize_repr};
use tokio::net::TcpStream;
use tokio_tungstenite::{MaybeTlsStream, WebSocketStream, connect_async, tungstenite as tungstenite};
use tungstenite::{Message};

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/// Error types that can occur while working with this crate
#[derive(Debug, thiserror::Error)]
pub enum Error {
    #[error("error with the websocket {0}")]
    Websocket(#[from] tungstenite::Error),
    #[error("error with Alpaca {0}")]
    Alpaca(#[from] AlpacaError),
    #[error("error in the conversion from/to JSON")]
    Json(#[from] serde_json::Error),
    #[error("BUG: {0}")]
    AuthDataBuilder(#[from] AuthDataBuilderError),
    #[error("BUG: {0}")]
    SubscriptionDataBuilder(#[from] SubscriptionDataBuilderError),
}

type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;

/// This is the object you'll want to create in order to interact with Alpaca's
/// market data api. The object allows both server to client and client to 
/// server communication (these responsibilities can be split for independant/
/// asynchronous processing).
pub struct Client {
    /// The portion of the client devoted to the client to server communication
    write : ClientSender,
    /// The portion of the client devoted to the server to client communication
    read  : ClientReceiver,
}
impl Client {
    /// Creates a client that fetches data from the given source.
    pub async fn new(source: Source) -> Result<Self, Error> {
        // --- Connect to websocket
        let url = format!("{}{}", WSS_ENDPOINT, source);
        let (socket, _rsp) = connect_async(url).await?;
        let (write, read)  = socket.split();
        let write          = ClientSender::new(write);
        let read           = ClientReceiver::new(read);
        //
        Ok(Self {write, read})
    }
    /// Splits the send/receive responsibilities for independant processing
    pub fn split(self) -> (ClientSender, ClientReceiver) {
        (self.write, self.read)
    }
    /// Authenticates the client
    pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
        self.write.authenticate(auth).await
    }
    /// Subscribe for realtime data about certain trades, quotes or bars
    pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.write.subscribe(sub).await
    }
    /// Unsubscribe from realtime data about certain trades, quotes or bars
    pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.write.unsubscribe(sub).await
    }
    /// Returns the stream which is used to receive the responses from the server
    pub fn stream(self) -> impl StreamExt<Item=Response> {
        self.read.stream()
    }
}
/// The portion of the client devoted to the client to server communication
pub struct ClientSender {
    write : SplitSink<WsStream, Message>,
}
impl ClientSender {
    /// Creates a new instance from a given write sink
    pub fn new(write: SplitSink<WsStream, Message>) -> Self {
        Self {write}
    }
    /// Authenticates the client
    pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
        self.action(Action::Authenticate(auth)).await
    }
    /// Subscribe for realtime data about certain trades, quotes or bars
    pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.action(Action::Subscribe(sub)).await
    }
    /// Unsubscribe from realtime data about certain trades, quotes or bars
    pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.action(Action::Unsubscribe(sub)).await
    }
    /// Performs the specified action on the server
    pub async fn action(&mut self, action: Action) -> Result<(), Error> {
        let json = serde_json::to_string(&action)?;
        self.write.send(Message::Text(json)).await?;
        Ok(())
    }
}
/// The portion of the client devoted to the server to client communication.
/// This object is essentially used as a means to obtain an opaquely-types 
/// stream of Responses.
pub struct ClientReceiver {
    read: SplitStream<WsStream>
}
impl ClientReceiver {
    /// Create a new instance from a given message stream
    pub fn new(read: SplitStream<WsStream>) -> Self {
        Self {read}
    }
    /// Returns the stream which is used to receive the responses from the server
    pub fn stream(self) -> impl StreamExt<Item=Response> {
        self.read
        .filter_map(|m| async move {
            if let Ok(Message::Text(t)) = m {
                let data: Vec<Response> = serde_json::from_str(&t).unwrap_or_else(|_| panic!("unexpected message '{}'", t));
                let data = futures::stream::iter(data);
                Some(data)
            } else {
                None
            }
        })
        .flatten()
    }
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

/*******************************************************************************
 * CLIENT TO SERVER ************************************************************
 ******************************************************************************/

/// The websocket endpoint used to communicate with Alpaca's real time data v2 API
const WSS_ENDPOINT : &str = "wss://stream.data.alpaca.markets/v2/";

/// The data source for the real time data
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum Source {
    /// Investor's Exchange (IEX) is the default datasource, and the one 
    /// included in the free subscription plan
    IEX,
    /// If you intend to use SIP as data source (unlimited plan only)
    SIP
}
impl Default for Source {
    fn default() -> Self { Self::IEX }
}
impl std::fmt::Display for Source {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::IEX => write!(fmt, "iex"),
            Self::SIP => write!(fmt, "sip"),
        }
    }
}

/// In order to interact with the server over the websocket, you'll need to 
/// tell it what you want to do. Basically, the very first thing you'll want to
/// do after connecting is to authenticate (failure to to so within a few 
/// seconds will result in the receipt of an error control message).
///
/// Once authenticated you will have the opportunity to subscribe and 
/// unsubscribe from messages you want to receive from Alpaca.
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "action")]
pub enum Action {
    #[serde(rename = "auth")] 
    Authenticate(AuthData), 
    #[serde(rename = "subscribe")] 
    Subscribe(SubscriptionData),
    #[serde(rename = "unsubscribe")] 
    Unsubscribe(SubscriptionData),
}

/// After connecting you will have to authenticate as follows:
/// ```{"action":"auth","key":"PK************","secret":"************"}```
#[derive(Debug, Clone, Serialize, Builder)]
pub struct AuthData {
    key:    String,
    secret: String,
}

/// You can subscribe to trades, quotes and bars of a particular symbol 
/// (or * for every symbol in the case of bars). A subscribe message should 
/// contain what subscription you want to add to your current subscriptions in 
/// your session so you don’t have to send what you’re already subscribed to.
///
/// You can also omit either one of them (trades,quotes or bars) if you don’t 
/// want to subscribe to any symbols in that category but be sure to include at 
/// least one of the three.
///
/// Subscription data is also used when you mean to send an `unsubscribe` 
/// message that subtracts the list of subscriptions specified from your current
/// set of subscriptions.
#[derive(Debug, Clone, Serialize, Deserialize, Builder)]
pub struct SubscriptionData {
    #[builder(setter(strip_option), default)]
    trades: Option<Vec<String>>,
    #[builder(setter(strip_option), default)]
    quotes: Option<Vec<String>>,
    #[builder(setter(strip_option), default)]
    bars  : Option<Vec<String>>,
}


/*******************************************************************************
 * SERVER TO CLIENT ************************************************************
 ******************************************************************************/

/// Encapsulates the protocol errors
#[derive(Debug, thiserror::Error, Clone, Serialize, Deserialize)]
#[error("{message}")]
pub struct AlpacaError {
    /// Code identifying the problem
    #[serde(rename="code")]
    pub code: AlpacaErrorCode,
    /// Human readable explanation of the failure
    #[serde(rename="msg")]
    message: String,
}
/// Encapsulates the protocol errors codes
#[derive(Debug, Clone, Copy, Serialize_repr, Deserialize_repr)]
#[repr(u16)]
pub enum AlpacaErrorCode {
    /// The message you sent to the server did not follow the specification
    /// ```[{"T":"error","code":400,"msg":"invalid syntax"}]```
    #[serde(rename="400")]
    InvalidSyntax = 400,
    /// You have attempted to subscribe or unsubscribe before authentication
    /// ```[{"T":"error","code":401,"msg":"not authenticated"}]```
    #[serde(rename="401")]
    NotAuthenticated = 401,
    /// You have provided invalid authentication credentials.
    /// ```[{"T":"error","code":402,"msg":"auth failed"}]```
    #[serde(rename="402")]
    AuthFailed = 402,
    /// You have already successfully authenticated during your current session.
    /// ```[{"T":"error","code":403,"msg":"already authenticated"}]```
    #[serde(rename="403")]
    AlreadyAuthenticated = 403,
    /// You failed to successfully authenticate after connecting. 
    /// You have a few seconds to authenticate after connecting.
    /// ```[{"T":"error","code":404,"msg":"auth timeout"}]```
    #[serde(rename="404")]
    AuthTimeout  = 404,
    /// The symbol subscription request you sent would put you over the limit 
    /// set by your subscription package. If this happens your symbol 
    /// subscriptions are the same as they were before you sent the request 
    /// that failed.
    /// ```[{"T":"error","code":405,"msg":"symbol limit exceeded"}]```
    #[serde(rename="405")]
    SymbolLimitExceeded = 405,
    /// You already have an ongoing authenticated session.
    /// ```[{"T":"error","code":406,"msg":"connection limit exceeded"}]```
    #[serde(rename="406")]
    ConnectionLimitExceeded = 406,
    /// You may receive this if you are too slow to process the messages sent 
    /// by the server. Please note that this is not guaranteed to arrive 
    /// before you are disconnected to avoid keeping slow connections active 
    /// forever
    /// ```[{"T":"error","code":407,"msg":"slow client"}]```
    #[serde(rename="407")]
    SlowClient = 407,
    /// Your account does not have access to Data v2.
    /// ```[{"T":"error","code":408,"msg":"v2 not enabled"}]```
    #[serde(rename="408")]
    DataV2NotEnabled = 408,
    /// You have attempted to access a data source not available in your 
    /// subscription package.
    /// ```[{"T":"error","code":409,"msg":"insufficient subscription"}]```
    #[serde(rename="409")]
    InsufficientSubscription = 409,
    /// An unexpected error occurred on our end and we are investigating the issue.
    /// ```[{"T":"error","code":500,"msg":"internal error"}```
    #[serde(rename="500")]
    InternalError = 500,
}

/// Every message you receive from the server will be in the format:
///
/// ```
/// [{"T": "{message_type}", {contents}},...]
/// ```
/// Control messages (i.e. where "T" is error, success or subscription) always 
/// arrive in arrays of size one to make their processing easier.
/// 
/// Data points however may arrive in arrays that have a length that is greater 
/// than one. This is to facilitate clients whose connection is not fast enough 
/// to handle data points sent one by one. Our server buffers the outgoing 
/// messages but slow clients may get disconnected if their buffer becomes full.
///
/// # Communication flow
/// The communication can be thought of as two separate phases: 
/// establishment and receiving data.
/// 
/// ## Establishment
/// To establish the connection first you will need to connect to our server 
/// using the URL above. Upon successfully connecting, you will receive the 
/// welcome message: 
/// ```
/// [{"T":"success","msg":"connected"}]
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "T")]
pub enum Response {
    /// Obviously, this variant is used to denote control message informing 
    /// you that some error has happened. You may receive an error during your 
    /// session. You can differentiate between them using the list below:
    /// 
    /// * The message you sent to the server did not follow the specification
    ///   ```[{"T":"error","code":400,"msg":"invalid syntax"}]```
    /// 
    /// * You have attempted to subscribe or unsubscribe before authentication
    ///   ```[{"T":"error","code":401,"msg":"not authenticated"}]```
    ///
    /// * You have provided invalid authentication credentials.
    ///   ```[{"T":"error","code":402,"msg":"auth failed"}]```
    ///
    /// * You have already successfully authenticated during your current session.
    ///   ```[{"T":"error","code":404,"msg":"auth timeout"}]```
    ///
    /// * You failed to successfully authenticate after connecting. 
    ///   You have a few seconds to authenticate after connecting.
    ///   ```[{"T":"error","code":404,"msg":"auth timeout"}]```
    /// 
    /// * The symbol subscription request you sent would put you over the limit 
    ///   set by your subscription package. If this happens your symbol 
    ///   subscriptions are the same as they were before you sent the request 
    ///   that failed.
    ///   ```[{"T":"error","code":405,"msg":"symbol limit exceeded"}]```
    /// 
    /// * You already have an ongoing authenticated session.
    ///   ```[{"T":"error","code":406,"msg":"connection limit exceeded"}]```
    ///
    /// * You may receive this if you are too slow to process the messages sent 
    ///   by the server. Please note that this is not guaranteed to arrive 
    ///   before you are disconnected to avoid keeping slow connections active 
    ///   forever
    ///   ```[{"T":"error","code":407,"msg":"slow client"}]```
    ///
    /// * Your account does not have access to Data v2.
    ///   ```[{"T":"error","code":408,"msg":"v2 not enabled"}]```
    ///
    /// * You have attempted to access a data source not available in your 
    ///   subscription package.
    ///   ```[{"T":"error","code":409,"msg":"insufficient subscription"}]```
    ///
    /// * An unexpected error occurred on our end and we are investigating the issue.
    ///   ```[{"T":"error","code":500,"msg":"internal error"}```
    #[serde(rename="error")]
    Error(AlpacaError),
    /// This variant denotes a **control message** meant to inform you of the
    /// successful completion of the action you requested. For instance, 
    /// upon successfully connecting, you will receive the  welcome message: 
    /// ```
    /// [{"T":"success","msg":"connected"}]
    /// ```
    ///
    /// Similarly, after connecting with proper credentials you will receive 
    /// another success message: 
    /// ```
    /// [{"T":"success","msg":"authenticated"}]
    /// ```
    #[serde(rename="success")]
    Success{#[serde(rename="msg")] message: String},
    /// After subscribing or unsubscribing you will receive a message that 
    /// describes your current list of subscriptions.
    /// ```
    /// [{"T":"subscription","trades":["AAPL"],"quotes":["AMD","CLDR"],"bars":["IBM","AAPL","VOO"]}]
    /// ```
    ///
    /// **Note**: 
    /// You will always receive your entire list of subscriptions, as  
    /// illustrated by the sample communication excerpt below: 
    /// ```
    /// > {"action": "subscribe", "trades": ["AAPL"], "quotes": ["AMD", "CLDR"], "bars": ["*"]}
    /// < [{"T":"subscription","trades":["AAPL"],"quotes":["AMD","CLDR"],"bars":["*"]}]
    /// > {"action": "unsubscribe", "bars": ["*"]}
    /// > [{"T":"subscription","trades":["AAPL"],"quotes":["AMD","CLDR"],"bars":[]}]
    /// ```
    #[serde(rename="subscription")]
    Subscription(SubscriptionData),

    // --- DATA POINTS --------------------------------------------------------
    #[serde(rename="t")]
    Trade(TradeData),
    #[serde(rename="q")]
    Quote(QuoteData),
    #[serde(rename="b")]
    Bar(BarData),
}

/*******************************************************************************
 * DATA POINTS *****************************************************************
 ******************************************************************************/

 /// Datapoint encapsulating informations about a given trade
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct TradeData {
     /// The symbol
     #[serde(rename="S")]
     pub symbol: String,
     /// Trade identifier
     #[serde(rename="i")]
     pub trade_id: i128,
     /// exchange code where the trade occurred
     #[serde(rename="x")]
     pub exchange_code: Exchange,
     /// trade price
     #[serde(rename="p")]
     pub trade_price: f64,
     /// trade size
     #[serde(rename="s")]
     pub trade_size: u64,
     /// RFC-3339 formatted timestamp with nanosecond precision.
     #[serde(rename="t")]
     pub timestamp: DateTime<Utc>,
     /// Condition.
     ///
     /// # Note 
     /// Each feed/exchange uses its own set of codes to identify trade and quote 
     /// conditions, so the same condition may have a different code depending on 
     /// the originator of the data. For more details, please refer to alpaca's 
     /// documentation page:
     /// <https://alpaca.markets/docs/api-documentation/api-v2/market-data/alpaca-data-api-v2/#conditions>
     /// and 
     /// <https://alpaca.markets/docs/api-documentation/api-v2/market-data/alpaca-data-api-v2/#quote-conditions>
     #[serde(rename="c")]
     pub condition: String,
     /// Tape
     #[serde(rename="z")]
     pub tape: String,
 }

 /// Datapoint encapsulating a quote
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct QuoteData {
     /// The symbol
     #[serde(rename="S")]
     pub symbol: String,
     /// ask exchange code
     #[serde(rename="ax")]
     pub ask_exchange: Exchange,
     /// ask price
     #[serde(rename="ap")]
     pub ask_price: f64,
     /// ask size
     #[serde(rename="as")]
     pub ask_size: usize,
     /// bid exchange code
     #[serde(rename="bx")]
     pub bid_exchange: Exchange,
     /// bid price
     #[serde(rename="bp")]
     pub bid_price: f64,
     /// ask size
     #[serde(rename="bs")]
     pub bid_size: usize,
     /// RFC-3339 formatted timestamp with nanosecond precision.
     #[serde(rename="t")]
     pub timestamp: DateTime<Utc>,
     /// Condition.
     ///
     /// # Note 
     /// Each feed/exchange uses its own set of codes to identify trade and quote 
     /// conditions, so the same condition may have a different code depending on 
     /// the originator of the data. For more details, please refer to alpaca's 
     /// documentation page:
     /// <https://alpaca.markets/docs/api-documentation/api-v2/market-data/alpaca-data-api-v2/#conditions>
     /// and 
     /// <https://alpaca.markets/docs/api-documentation/api-v2/market-data/alpaca-data-api-v2/#quote-conditions>
     #[serde(rename="c")]
     pub condition: String,
     /// Tape
     #[serde(rename="z")]
     pub tape: String,
 }

/// Datapoint encapsulating a 'bar' (a.k.a. OHLC)
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub struct BarData {
    /// The symbol
    #[serde(rename="S")]
    pub symbol: String,
    // open price
    #[serde(rename="o")]
    pub open_price: f64,
    // high price
    #[serde(rename="h")]
    pub high_price: f64,
    // low price
    #[serde(rename="l")]
    pub low_price: f64,
    // close price
    #[serde(rename="c")]
    pub close_price: f64,
    // volume
    #[serde(rename="v")]
    pub volume: u64,
    /// RFC-3339 formatted timestamp with nanosecond precision.
    #[serde(rename="t")]
    pub timestamp: DateTime<Utc>,
}

/// List of stock exchanges which are supported by Alpaca.
/// The tape id of each exchange is returned in all market data requests. 
/// You can use this table to map the code to an exchange.
 #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
 pub enum Exchange {
    /// A     NYSE American (AMEX)     
    #[serde(rename="A")]
    Amex, 
    /// B     NASDAQ OMX BX     
    #[serde(rename="B")]
    NasdaqOmxBx,
    /// C     National Stock Exchange     
    #[serde(rename="C")]
    NationalStockExchange,
    /// D     FINRA ADF     
    #[serde(rename="D")]
    FinraAdf,
    /// E     Market Independent     
    #[serde(rename="E")]
    MarketIndependent,
    /// H     MIAX     
    #[serde(rename="H")]
    Miax,
    /// I     International Securities Exchange     
    #[serde(rename="I")]
    InternationalSecuritiesExchange,
    /// J     Cboe EDGA     
    #[serde(rename="J")]
    CboeEdga,
    /// K     Cboe EDGX     
    #[serde(rename="K")]
    CboeEdgx,
    /// L     Long Term Stock Exchange     
    #[serde(rename="L")]
    LongTermStockExchange,
    /// M     Chicago Stock Exchange     
    #[serde(rename="M")]
    ChicagoStockExchange,
    /// N     New York Stock Exchange     
    #[serde(rename="N")]
    NewYorkStockExchange,
    /// P     NYSE Arca     
    #[serde(rename="P")]
    NyseArca,
    /// Q     NASDAQ OMX     
    #[serde(rename="Q")]
    NasdaqOmx,
    /// S     NASDAQ Small Cap     
    #[serde(rename="S")]
    NasdaqSmallCap,
    /// T     NASDAQ Int     
    #[serde(rename="T")]
    NasdaqInt,
    /// U     Members Exchange     
    #[serde(rename="U")]
    MembersExchange,
    /// V     IEX     
    #[serde(rename="V")]
    Iex,
    /// W     CBOE     
    #[serde(rename="W")]
    Cboe,
    /// X     NASDAQ OMX PSX     
    #[serde(rename="X")]
    NasdaqOmxPsx,
    /// Y     Cboe BYX     
    #[serde(rename="Y")]
    CboeByx,
    /// Z     Cboe BZX
    #[serde(rename="Z")]
    CboeBzx,
 }