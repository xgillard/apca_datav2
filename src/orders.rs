//! This module provides an easy access to the orders API offered by Alpaca.
//! 
//! # Orders
//! 
//! The Orders API allows a user to monitor, place and cancel their orders with
//! Alpaca. Each order has a unique identifier provided by the client. This 
//! client-side unique order ID will be automatically generated by the system 
//! if not provided by the client, and will be returned as part of the order 
//! object along with the rest of the fields described below. Once an order is 
//! placed, it can be queried using the client-side order ID to check the
//! status. Updates on open orders at Alpaca will also be sent over the 
//! streaming interface, which is the recommended method of maintaining order 
//! state.
//! 
//! For further details on order functionality, please see the 
//! ![orders](https://alpaca.markets/docs/trading-on-alpaca/orders "Trading On Alpaca - Orders") page.
//! 
//! Please note that body parameters should be passed using a JSON encoded body.

use chrono::{DateTime, Utc};
use reqwest::RequestBuilder;
use serde::{Deserialize, Serialize};
use derive_builder::Builder;
use serde_repr::{Deserialize_repr, Serialize_repr};

use crate::{data::{AuthData, Direction, Order, OrderClass, OrderSide, OrderType, TimeInForce}, errors::{Error, OrderError, maybe_convert_to_order_error, status_code_to_order_error}};


/// Base URL to interact with live trading api
pub const LIVE_TRADING_URL: &str = "https://api.alpaca.markets";
/// Base URL to interact with paper trading api
pub const PAPER_TRADING_URL: &str = "https://paper-api.alpaca.markets";

/// Path to the orders endpoint (used to list and place orders)
pub const ORDERS: &str = "v2/orders";

/// Header used to send the key-id authentication
pub const APCA_API_KEY_ID: &str = "APCA-API-KEY-ID";
/// Header used to send the secret-key for authentication
pub const APCA_API_SECRET_KEY: &str = "APCA-API-SECRET-KEY";

pub struct Client {
  auth:   AuthData,
  client: reqwest::Client,
  base_url: &'static str,
}
impl Client {
  pub fn live(auth: AuthData) -> Self {
    Self::new(auth, true)
  }
  pub fn paper(auth: AuthData) -> Self {
    Self::new(auth, false)
  }
  pub fn new(auth: AuthData, live: bool) -> Self {
    let base_url = if live { LIVE_TRADING_URL } else { PAPER_TRADING_URL };
    Self {auth, client: reqwest::Client::new(), base_url}
  }
  fn get_authenticated(&self, url: &str) -> RequestBuilder {
      self.client.get(url)
          .header(APCA_API_KEY_ID,     &self.auth.key)
          .header(APCA_API_SECRET_KEY, &self.auth.secret)        
  }
  fn post_authenticated(&self, url: &str) -> RequestBuilder {
    self.client.post(url)
        .header(APCA_API_KEY_ID,     &self.auth.key)
        .header(APCA_API_SECRET_KEY, &self.auth.secret)        
  }
  fn patch_authenticated(&self, url: &str) -> RequestBuilder {
      self.client.patch(url)
          .header(APCA_API_KEY_ID,     &self.auth.key)
          .header(APCA_API_SECRET_KEY, &self.auth.secret)        
  }
  fn delete_authenticated(&self, url: &str) -> RequestBuilder {
      self.client.delete(url)
          .header(APCA_API_KEY_ID,     &self.auth.key)
          .header(APCA_API_SECRET_KEY, &self.auth.secret)        
  }

  /// Retrieves a list of orders for the account, filtered by the supplied 
  /// query parameters.
  pub async fn list_orders(&self, request: &ListOrderRequest) -> Result<Vec<Order>, Error> {
    let url = format!("{}/{}", self.base_url, ORDERS);
    let rsp = self.get_authenticated(&url)
      .query(request)
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  }

  /// Places a new order for the given account. An order request may be 
  /// rejected if the account is not authorized for trading, or if the tradable
  /// balance is insufficient to fill the order.
  pub async fn place_order(&self, request: &PlaceOrderRequest) -> Result<Order, Error> {
    let url = format!("{}/{}", self.base_url, ORDERS);
    let rsp = self.post_authenticated(&url)
      .json(request)
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  }

  /// Retrieves a single order for the given order_id. 
  /// 
  /// ## Parameters
  /// - id: the order uuid
  /// - nested: If true, the result will roll up multi-leg orders under the 
  ///     legs field of primary order.
  pub async fn get_by_id(&self, id: &str, nested: bool) -> Result<Order, Error> {
    let url = format!("{}/{}/{}", self.base_url, ORDERS, id);
    let rsp = self.get_authenticated(&url)
      .query(&("nested", nested))
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  } 

  ///  Retrieves a single order for the given client_order_id. . 
  /// 
  /// ## Parameters
  /// - id: the client order-id
  pub async fn get_by_client_id(&self, id: &str) -> Result<Order, Error> {
    let url = format!("{}/{}:by_client_order_id", self.base_url, ORDERS);
    let rsp = self.get_authenticated(&url)
      .query(&("client_order_id", id))
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  } 

  /// Replaces a single order with updated parameters. Each parameter overrides 
  /// the corresponding attribute of the existing order. The other attributes 
  /// remain the same as the existing order.
  /// A success return code from a replaced order does NOT guarantee the 
  /// existing open order has been replaced. If the existing open order is 
  /// filled before the replacing (new) order reaches the execution venue, the 
  /// replacing (new) order is rejected, and these events are sent in the 
  /// trade_updates stream channel. Read more about the trade stream updates 
  /// ![](https://docs.alpaca.markets/api-documentation/api-v2/streaming/#order-updates "here").
  /// 
  /// While an order is being replaced, buying power is reduced by the larger 
  /// of the two orders that have been placed (the old order being replaced, 
  /// and the newly placed order to replace it). If you are replacing a buy 
  /// entry order with a higher limit price than the original order, the buying 
  /// power is calculated based on the newly placed order. If you are replacing 
  /// it with a lower limit price, the buying power is calculated based on the 
  /// old order.
  pub async fn replace(&self, id: &str, replacement: &ReplacementRequest) -> Result<Order, Error> {
    let url = format!("{}/{}/{}", self.base_url, ORDERS, id);
    let rsp = self.patch_authenticated(&url)
      .json(replacement)
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  } 

  /// Attempts to cancel all open orders. A response will be provided for 
  /// each order that is attempted to be cancelled. If an order is no longer 
  /// cancelable, the server will respond with status 500 and reject the request.
  /// 
  /// Response
  /// HTTP 207 Multi-Status with body; an array of objects that include the 
  /// order id and http status code for each status request.
  pub async fn cancel_all_orders(&self) -> Result<Vec<CancellationData>, Error> {
    let url = format!("{}/{}", self.base_url, ORDERS);
    let rsp = self.delete_authenticated(&url)
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  }

  /// Attempts to cancel an open order. If the order is no longer cancelable (
  /// example: status="filled"), the server will respond with status 422, and 
  /// reject the request. Upon acceptance of the cancel request, it returns 
  /// status 204.
  pub async fn cancel_by_id(&self, id: &str) -> Result<CancelationStatus, Error> {
    let url = format!("{}/{}/{}", self.base_url, ORDERS, id);
    let rsp = self.delete_authenticated(&url)
      .send().await
      .map_err(maybe_convert_to_order_error)?;

    match rsp.status().as_u16() {
      200 => Ok(CancelationStatus::Success),
      204 => Ok(CancelationStatus::NoContent),
      403 => Err(Error::Order(OrderError::Forbidden)),
      404 => Err(Error::Order(OrderError::NotFound)),
      422 => Err(Error::Order(OrderError::Unprocessable)),
      500 => Err(Error::Order(OrderError::InternalError)),
      s   => Err(Error::Unexpected(s))
    }
  }
}

/// Status when searching for a given order
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SearchOrderStatus {
  #[serde(rename="open")]
  Open, 
  #[serde(rename="closed")]
  Closed,
  #[serde(rename="all")]
  All,
}

/// List Order Requests
#[derive(Builder, Debug, Clone, Serialize, Deserialize)]
pub struct ListOrderRequest {
  /// Order status to be queried. open, closed or all. Defaults to open.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub status: Option<SearchOrderStatus>,
  /// The maximum number of orders in response. Defaults to 50 and max is 500.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub limit: Option<u32>,
  /// The response will include only ones submitted after this timestamp (exclusive.)
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub after: Option<DateTime<Utc>>,
  /// The response will include only ones submitted until this timestamp (exclusive.)
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub until: Option<DateTime<Utc>>,
  /// The chronological order of response based on the submission time. 
  /// asc or desc. Defaults to desc.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub direction: Option<Direction>,
  /// If true, the result will roll up multi-leg orders under the legs field 
  /// of primary order.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub nested: Option<bool>,
  /// A comma-separated list of symbols to filter by (ex. “AAPL,TSLA,MSFT”). 
  /// A currency pair is required for crypto orders (ex. “BTCUSD,BCHUSD,LTCUSD,ETCUSD”).
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub symbols: Option<String>,
}

/// Place Order Requests
#[derive(Builder, Debug, Clone, Serialize, Deserialize)]
pub struct PlaceOrderRequest {
  /// symbol, asset ID, or currency pair to identify the asset to trade
  pub symbol: String,
  /// number of shares to trade. Can be fractionable for only market and day order types
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub qty: Option<f64>,
  /// dollar amount to trade. Cannot work with qty. 
  /// Can only work for market order types and day for time in force.
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub notional: Option<f64>,
  /// buy or sell
  pub side: OrderSide,
  /// market, limit, stop, stop_limit, or trailing_stop
  #[serde(rename="type")]
  #[builder(default="crate::data::OrderType::Market")]
  pub order_type: OrderType,
  /// day, gtc, opg, cls, ioc, fok. Please see Understand Orders for more info.
  #[builder(default="crate::data::TimeInForce::Day")]
  pub time_in_force: TimeInForce,
  /// required if type is limit or stop_limit
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub limit_price: Option<f64>,
  /// required if type is stop or stop_limit
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub stop_price: Option<f64>,
  /// this or trail_percent is required if type is trailing_stop
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub trail_price: Option<f64>,
  /// this or trail_percent is required if type is trailing_stop
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub trail_percent: Option<f64>,
  /// (default) false. If true, order will be eligible to execute in 
  /// premarket/afterhours. Only works with type limit and time_in_force day.
  #[builder(default="false")]
  pub extended_hours: bool,
  /// A unique identifier for the order. Automatically generated if not sent.
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub client_order_id: Option<String>,
  /// simple, bracket, oco or oto. For details of non-simple order classes, 
  /// please see Bracket Order Overview
  #[builder(default="crate::data::OrderClass::Simple")]
  pub order_class: OrderClass,
}
/// Additional parameters for take-profit leg of advanced orders
#[derive(Builder, Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TakeProfitRequest {
  /// required for bracket orders
  pub limit_price: f64,
}
/// Additional parameters for stop-loss leg of advanced orders
#[derive(Builder, Debug, Clone, Copy, Serialize, Deserialize)]
pub struct StopLoss {
  /// required for bracket orders
  pub stop_price: f64,
  /// the stop-loss order becomes a stop-limit order if specified
  pub limit_price: f64,
}
/// Replace Order Requests
/// 
/// Replaces a single order with updated parameters. Each parameter overrides 
/// the corresponding attribute of the existing order. The other attributes 
/// remain the same as the existing order.
/// A success return code from a replaced order does NOT guarantee the 
/// existing open order has been replaced. If the existing open order is 
/// filled before the replacing (new) order reaches the execution venue, the 
/// replacing (new) order is rejected, and these events are sent in the 
/// trade_updates stream channel. Read more about the trade stream updates 
/// ![](https://docs.alpaca.markets/api-documentation/api-v2/streaming/#order-updates "here").
/// 
/// While an order is being replaced, buying power is reduced by the larger 
/// of the two orders that have been placed (the old order being replaced, 
/// and the newly placed order to replace it). If you are replacing a buy 
/// entry order with a higher limit price than the original order, the buying 
/// power is calculated based on the newly placed order. If you are replacing 
/// it with a lower limit price, the buying power is calculated based on the 
/// old order.
/// 
/// Note: A replacement request is not tied to any specific order. It can thus
/// be reused multiple times without needing a mutable access to the replacement
/// request.
/// 
#[derive(Builder, Debug, Clone, Serialize, Deserialize)]
pub struct ReplacementRequest {
  /// number of shares to trade
  /// 
  /// FIXME: (in the docs)
  /// Does it make sense that this parameter be an integer rather than a plain
  /// floating point number ?
  pub qty: Option<u32>,
  /// day, gtc, opg, cls, ioc, fok. 
  pub time_in_force: Option<TimeInForce>,
  /// required if type is limit or stop_limit
  pub limit_price: Option<f64>,
  /// required if type is stop or stop_limit
  pub stop_price: Option<f64>,
  /// the new value of the trail_price or trail_percent value 
  /// (works only for type="trailing_stop”)
  pub trail: Option<f64>,
  /// A unique identifier for the order. Automatically generated if not sent.
  pub client_order_id: Option<String>
}

/// A notification wrt the status of a cancelation request
#[derive(Builder, Debug, Clone, Serialize, Deserialize)]
pub struct CancellationData {
  /// The order whose cancelation has been requested.
  pub id: String,
  /// The cancelation status
  pub status: CancelationStatus 
}
/// Basically an http status code which is interpreted in the context of an 
/// order cancelation request
#[derive(Debug, Clone, Serialize_repr, Deserialize_repr)]
 #[repr(u16)]
pub enum CancelationStatus {
  /// Cancelation succeeded
  Success = 200,
  /// The request has been sucessfully processed but there is no reply info.
  NoContent = 204,
  /// The order was not found
  NotFound = 404,
  /// The order cannot be canceled
  Unprocessable = 422
}