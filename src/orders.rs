//! This module provides an easy access to the orders API offered by Alpaca.
//! 
//! # Orders
//! 
//! The Orders API allows a user to monitor, place and cancel their orders with
//! Alpaca. Each order has a unique identifier provided by the client. This 
//! client-side unique order ID will be automatically generated by the system 
//! if not provided by the client, and will be returned as part of the order 
//! object along with the rest of the fields described below. Once an order is 
//! placed, it can be queried using the client-side order ID to check the
//! status. Updates on open orders at Alpaca will also be sent over the 
//! streaming interface, which is the recommended method of maintaining order 
//! state.
//! 
//! For further details on order functionality, please see the 
//! ![orders](https://alpaca.markets/docs/trading-on-alpaca/orders "Trading On Alpaca - Orders") page.
//! 
//! Please note that body parameters should be passed using a JSON encoded body.

use chrono::{DateTime, Utc};
use reqwest::RequestBuilder;
use serde::{Deserialize, Serialize};
use derive_builder::Builder;

use crate::{data::{AuthData, Direction, Order, OrderClass, OrderSide, OrderType, TimeInForce}, errors::{Error, maybe_convert_to_order_error, status_code_to_order_error}};


/// Base URL to interact with live trading api
pub const LIVE_TRADING_URL: &str = "https://api.alpaca.markets";
/// Base URL to interact with paper trading api
pub const PAPER_TRADING_URL: &str = "https://paper-api.alpaca.markets";

/// Path to the orders endpoint (used to list and place orders)
pub const ORDERS: &str = "v2/orders";

/// Header used to send the key-id authentication
pub const APCA_API_KEY_ID: &str = "APCA-API-KEY-ID";
/// Header used to send the secret-key for authentication
pub const APCA_API_SECRET_KEY: &str = "APCA-API-SECRET-KEY";

pub struct Client {
  auth:   AuthData,
  client: reqwest::Client,
  base_url: &'static str,
}
impl Client {
  pub fn live(auth: AuthData) -> Self {
    Self::new(auth, true)
  }
  pub fn paper(auth: AuthData) -> Self {
    Self::new(auth, false)
  }
  pub fn new(auth: AuthData, live: bool) -> Self {
    let base_url = if live { LIVE_TRADING_URL } else { PAPER_TRADING_URL };
    Self {auth, client: reqwest::Client::new(), base_url}
  }
  #[allow(dead_code)]
  fn get_authenticated(&self, url: &str) -> RequestBuilder {
      self.client.get(url)
          .header(APCA_API_KEY_ID,     &self.auth.key)
          .header(APCA_API_SECRET_KEY, &self.auth.secret)        
  }
  fn post_authenticated(&self, url: &str) -> RequestBuilder {
    self.client.post(url)
        .header(APCA_API_KEY_ID,     &self.auth.key)
        .header(APCA_API_SECRET_KEY, &self.auth.secret)        
  }

  /// Retrieves a list of orders for the account, filtered by the supplied 
  /// query parameters.
  pub async fn list_orders(&self, request: &ListOrderRequest) -> Result<Vec<Order>, Error> {
    let url = format!("{}/{}", self.base_url, ORDERS);
    let rsp = self.get_authenticated(&url)
      .query(request)
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  }

  /// Places a new order for the given account. An order request may be 
  /// rejected if the account is not authorized for trading, or if the tradable
  /// balance is insufficient to fill the order.
  pub async fn place_order(&self, request: &PlaceOrderRequest) -> Result<Order, Error> {
    let url = format!("{}/{}", self.base_url, ORDERS);
    let rsp = self.post_authenticated(&url)
      .json(request)
      .send().await
      .map_err(maybe_convert_to_order_error)?;
    status_code_to_order_error(rsp).await
  }
}

/// Status when searching for a given order
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum SearchOrderStatus {
  #[serde(rename="open")]
  Open, 
  #[serde(rename="closed")]
  Closed,
  #[serde(rename="all")]
  All,
}


/// List Order Requests
#[derive(Builder, Debug, Clone, Serialize, Deserialize)]
pub struct ListOrderRequest {
  /// Order status to be queried. open, closed or all. Defaults to open.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub status: Option<SearchOrderStatus>,
  /// The maximum number of orders in response. Defaults to 50 and max is 500.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub limit: Option<u32>,
  /// The response will include only ones submitted after this timestamp (exclusive.)
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub after: Option<DateTime<Utc>>,
  /// The response will include only ones submitted until this timestamp (exclusive.)
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub until: Option<DateTime<Utc>>,
  /// The chronological order of response based on the submission time. 
  /// asc or desc. Defaults to desc.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub direction: Option<Direction>,
  /// If true, the result will roll up multi-leg orders under the legs field 
  /// of primary order.
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub nested: Option<bool>,
  /// A comma-separated list of symbols to filter by (ex. “AAPL,TSLA,MSFT”). 
  /// A currency pair is required for crypto orders (ex. “BTCUSD,BCHUSD,LTCUSD,ETCUSD”).
  #[builder(setter(strip_option), default="None")]
  #[serde(skip_serializing_if = "Option::is_none")]
  pub symbols: Option<String>,
}

/// Place Order Requests
#[derive(Builder, Debug, Clone, Serialize, Deserialize)]
pub struct PlaceOrderRequest {
  /// symbol, asset ID, or currency pair to identify the asset to trade
  pub symbol: String,
  /// number of shares to trade. Can be fractionable for only market and day order types
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub qty: Option<f64>,
  /// dollar amount to trade. Cannot work with qty. 
  /// Can only work for market order types and day for time in force.
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub notional: Option<f64>,
  /// buy or sell
  pub side: OrderSide,
  /// market, limit, stop, stop_limit, or trailing_stop
  #[serde(rename="type")]
  #[builder(default="crate::data::OrderType::Market")]
  pub order_type: OrderType,
  /// day, gtc, opg, cls, ioc, fok. Please see Understand Orders for more info.
  #[builder(default="crate::data::TimeInForce::Day")]
  pub time_in_force: TimeInForce,
  /// required if type is limit or stop_limit
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub limit_price: Option<f64>,
  /// required if type is stop or stop_limit
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub stop_price: Option<f64>,
  /// this or trail_percent is required if type is trailing_stop
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub trail_price: Option<f64>,
  /// this or trail_percent is required if type is trailing_stop
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub trail_percent: Option<f64>,
  /// (default) false. If true, order will be eligible to execute in 
  /// premarket/afterhours. Only works with type limit and time_in_force day.
  #[builder(default="false")]
  pub extended_hours: bool,
  /// A unique identifier for the order. Automatically generated if not sent.
  #[builder(setter(strip_option))]
  #[builder(default="None")]
  pub client_order_id: Option<String>,
  /// simple, bracket, oco or oto. For details of non-simple order classes, 
  /// please see Bracket Order Overview
  #[builder(default="crate::data::OrderClass::Simple")]
  pub order_class: OrderClass,
}
/// Additional parameters for take-profit leg of advanced orders
#[derive(Builder, Debug, Clone, Copy, Serialize, Deserialize)]
pub struct TakeProfitRequest {
  /// required for bracket orders
  pub limit_price: f64,
}
/// Additional parameters for stop-loss leg of advanced orders
#[derive(Builder, Debug, Clone, Copy, Serialize, Deserialize)]
pub struct StopLoss {
  /// required for bracket orders
  pub stop_price: f64,
  /// the stop-loss order becomes a stop-limit order if specified
  pub limit_price: f64,
}