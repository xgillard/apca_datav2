//! This module provides an easy access to real time data API offered by Alpaca.
//! 
//! # Real-time data
//! Alpaca Data API v2 provides websocket streaming for trades, quotes and 
//! minute bars. This helps receive the most up to date market information that 
//! could help your trading strategy to act upon certain market movements.
//! 
//! Once a connection is established and you have successfully authenticated 
//! yourself you can subscribe to trades, quotes and minute bars for a 
//! particular symbol or multiple symbols.
//! 
//! ## Subscription plans
//! * **Free plan**:
//!   You can only connect to IEX data source. One concurrent connection is allowed.
//!   Subscription is limited to 30 channels at a time for trades (trades) and 
//!   quotes (quotes). We may support more channels in the future. There is no 
//!   limit for the number of channels with minute bars (bars). Minute bars are 
//!   based on the trades from IEX.
//! 
//! * **Unlimited plan**:
//!   There is no limit for the number of channels at a time for trades, 
//!   quotes and minute bars(trades,quotes and bars). Trades, quotes and mintue 
//!   bars are direct feeds from the CTA (administered by NYSE) and 
//!   UTP (administered by Nasdaq) SIPs.
//! 
//! ## Common behavior
//! To access real-time data use the URL below, substituting `iex` or `sip` to 
//! {source} depending on your subscription.
//! `wss://stream.data.alpaca.markets/v2/{source}`
//! 
//! Attemption to access a data source not available for your subscription will 
//! result in an error during authentication.
//! 
//! ### Message format
//! Every message you receive from the server will be in the format:
//! ```[{"T": "{message_type}", {contents}},...]``` 
//! 
//! Control messages (i.e. where "T" is error, success or subscription) always 
//! arrive in arrays of size one to make their processing easier.
//! 
//! Data points however may arrive in arrays that have a length that is greater 
//! than one. This is to facilitate clients whose connection is not fast enough 
//! to handle data points sent one by one. Our server buffers the outgoing 
//! messages but slow clients may get disconnected if their buffer becomes full.
//! 
//! ### Encoding and compression
//! Messages over the websocket are in encoded as clear text.
//! To reduce bandwidth requirements we have implemented compression as per 
//! RFC-7692. Our SDKs handle this for you so in most cases you won’t have to 
//! implement anything yourself.
//! 
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant 
//! timestamps. These correspond to when a trade was executed or a quote was 
//! generated. As these timestamps are generated by independent market 
//! participants, not the SIP, there is no requirement that the participant 
//! used a synchronized clock or nanosecond resolution. In certain cases due to 
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote 
//! has been reported) will appear before the participant timestamp. 
//! Additionally, though SIP timestamp’s have nanosecond resolution, the 
//! participant timestamps may have broader resolution such as milliseconds or 
//! seconds.

use crate::{entities::{BarData, QuoteData, TradeData}, errors::{Error, RealtimeErrorCode}};
use futures::{SinkExt, StreamExt, stream::{SplitSink, SplitStream}};
use tokio::net::TcpStream;
use tokio_tungstenite::{MaybeTlsStream, WebSocketStream, connect_async, tungstenite as tungstenite};
use tungstenite::{Message};
use serde::{Serialize, Deserialize};
use derive_builder::Builder;

/// The websocket endpoint used to communicate with Alpaca's real time data v2 API
const WSS_ENDPOINT : &str = "wss://stream.data.alpaca.markets/v2/";
type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;

/// This is the object you'll want to create in order to interact with Alpaca's
/// market data api. The object allows both server to client and client to 
/// server communication (these responsibilities can be split for independant/
/// asynchronous processing).
pub struct Client {
    /// The portion of the client devoted to the client to server communication
    write : ClientSender,
    /// The portion of the client devoted to the server to client communication
    read  : ClientReceiver,
}
impl Client {
    /// Creates a client that fetches data from the given source.
    pub async fn new(source: Source) -> Result<Self, Error> {
        // --- Connect to websocket
        let url = format!("{}{}", WSS_ENDPOINT, source);
        let (socket, _rsp) = connect_async(url).await?;
        let (write, read)  = socket.split();
        let write          = ClientSender::new(write);
        let read           = ClientReceiver::new(read);
        //
        Ok(Self {write, read})
    }
    /// Splits the send/receive responsibilities for independant processing
    pub fn split(self) -> (ClientSender, ClientReceiver) {
        (self.write, self.read)
    }
    /// Authenticates the client
    pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
        self.write.authenticate(auth).await
    }
    /// Subscribe for realtime data about certain trades, quotes or bars
    pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.write.subscribe(sub).await
    }
    /// Unsubscribe from realtime data about certain trades, quotes or bars
    pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.write.unsubscribe(sub).await
    }
    /// Returns the stream which is used to receive the responses from the server
    pub fn stream(self) -> impl StreamExt<Item=Response> {
        self.read.stream()
    }
}
/// The portion of the client devoted to the client to server communication
pub struct ClientSender {
    write : SplitSink<WsStream, Message>,
}
impl ClientSender {
    /// Creates a new instance from a given write sink
    pub fn new(write: SplitSink<WsStream, Message>) -> Self {
        Self {write}
    }
    /// Authenticates the client
    pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
        self.action(Action::Authenticate(auth)).await
    }
    /// Subscribe for realtime data about certain trades, quotes or bars
    pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.action(Action::Subscribe(sub)).await
    }
    /// Unsubscribe from realtime data about certain trades, quotes or bars
    pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.action(Action::Unsubscribe(sub)).await
    }
    /// Performs the specified action on the server
    pub async fn action(&mut self, action: Action) -> Result<(), Error> {
        let json = serde_json::to_string(&action)?;
        self.write.send(Message::Text(json)).await?;
        Ok(())
    }
}
/// The portion of the client devoted to the server to client communication.
/// This object is essentially used as a means to obtain an opaquely-types 
/// stream of Responses.
pub struct ClientReceiver {
    read: SplitStream<WsStream>
}
impl ClientReceiver {
    /// Create a new instance from a given message stream
    pub fn new(read: SplitStream<WsStream>) -> Self {
        Self {read}
    }
    /// Returns the stream which is used to receive the responses from the server
    pub fn stream(self) -> impl StreamExt<Item=Response> {
        self.read
        .filter_map(|m| async move {
            if let Ok(Message::Text(t)) = m {
                let data: Vec<Response> = serde_json::from_str(&t).unwrap_or_else(|_| panic!("unexpected message '{}'", t));
                let data = futures::stream::iter(data);
                Some(data)
            } else {
                None
            }
        })
        .flatten()
    }
}
/******************************************************************************
 * CLIENT TO SERVER ***********************************************************
 ******************************************************************************/
 
/// The data source for the real time data
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum Source {
    /// Investor's Exchange (IEX) is the default datasource, and the one 
    /// included in the free subscription plan
    IEX,
    /// If you intend to use SIP as data source (unlimited plan only)
    SIP
}
impl Default for Source {
    fn default() -> Self { Self::IEX }
}
impl std::fmt::Display for Source {
    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {
        match self {
            Self::IEX => write!(fmt, "iex"),
            Self::SIP => write!(fmt, "sip"),
        }
    }
}

/// In order to interact with the server over the websocket, you'll need to 
/// tell it what you want to do. Basically, the very first thing you'll want to
/// do after connecting is to authenticate (failure to to so within a few 
/// seconds will result in the receipt of an error control message).
///
/// Once authenticated you will have the opportunity to subscribe and 
/// unsubscribe from messages you want to receive from Alpaca.
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "action")]
pub enum Action {
    #[serde(rename = "auth")] 
    Authenticate(AuthData), 
    #[serde(rename = "subscribe")] 
    Subscribe(SubscriptionData),
    #[serde(rename = "unsubscribe")] 
    Unsubscribe(SubscriptionData),
}

/// After connecting you will have to authenticate as follows:
/// ```{"action":"auth","key":"PK************","secret":"************"}```
#[derive(Debug, Clone, Serialize, Builder)]
pub struct AuthData {
    pub key:    String,
    pub secret: String,
}

/// You can subscribe to trades, quotes and bars of a particular symbol 
/// (or * for every symbol in the case of bars). A subscribe message should 
/// contain what subscription you want to add to your current subscriptions in 
/// your session so you don’t have to send what you’re already subscribed to.
///
/// You can also omit either one of them (trades,quotes or bars) if you don’t 
/// want to subscribe to any symbols in that category but be sure to include at 
/// least one of the three.
///
/// Subscription data is also used when you mean to send an `unsubscribe` 
/// message that subtracts the list of subscriptions specified from your current
/// set of subscriptions.
#[derive(Debug, Clone, Serialize, Deserialize, Builder)]
pub struct SubscriptionData {
    #[builder(setter(strip_option), default)]
    pub trades: Option<Vec<String>>,
    #[builder(setter(strip_option), default)]
    pub quotes: Option<Vec<String>>,
    #[builder(setter(strip_option), default)]
    pub bars  : Option<Vec<String>>,
}


/******************************************************************************
 * SERVER TO CLIENT ***********************************************************
 ******************************************************************************/
/// Every message you receive from the server will be in the format:
///
/// ```json
/// [{"T": "{message_type}", {contents}},...]
/// ```
/// Control messages (i.e. where "T" is error, success or subscription) always 
/// arrive in arrays of size one to make their processing easier.
/// 
/// Data points however may arrive in arrays that have a length that is greater 
/// than one. This is to facilitate clients whose connection is not fast enough 
/// to handle data points sent one by one. Our server buffers the outgoing 
/// messages but slow clients may get disconnected if their buffer becomes full.
///
/// # Communication flow
/// The communication can be thought of as two separate phases: 
/// establishment and receiving data.
/// 
/// ## Establishment
/// To establish the connection first you will need to connect to our server 
/// using the URL above. Upon successfully connecting, you will receive the 
/// welcome message: 
/// ```json
/// [{"T":"success","msg":"connected"}]
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "T")]
pub enum Response {
    /// Obviously, this variant is used to denote control message informing 
    /// you that some error has happened. You may receive an error during your 
    /// session. You can differentiate between them using the list below:
    /// 
    /// * The message you sent to the server did not follow the specification
    ///   ```[{"T":"error","code":400,"msg":"invalid syntax"}]```
    /// 
    /// * You have attempted to subscribe or unsubscribe before authentication
    ///   ```[{"T":"error","code":401,"msg":"not authenticated"}]```
    ///
    /// * You have provided invalid authentication credentials.
    ///   ```[{"T":"error","code":402,"msg":"auth failed"}]```
    ///
    /// * You have already successfully authenticated during your current session.
    ///   ```[{"T":"error","code":404,"msg":"auth timeout"}]```
    ///
    /// * You failed to successfully authenticate after connecting. 
    ///   You have a few seconds to authenticate after connecting.
    ///   ```[{"T":"error","code":404,"msg":"auth timeout"}]```
    /// 
    /// * The symbol subscription request you sent would put you over the limit 
    ///   set by your subscription package. If this happens your symbol 
    ///   subscriptions are the same as they were before you sent the request 
    ///   that failed.
    ///   ```[{"T":"error","code":405,"msg":"symbol limit exceeded"}]```
    /// 
    /// * You already have an ongoing authenticated session.
    ///   ```[{"T":"error","code":406,"msg":"connection limit exceeded"}]```
    ///
    /// * You may receive this if you are too slow to process the messages sent 
    ///   by the server. Please note that this is not guaranteed to arrive 
    ///   before you are disconnected to avoid keeping slow connections active 
    ///   forever
    ///   ```[{"T":"error","code":407,"msg":"slow client"}]```
    ///
    /// * Your account does not have access to Data v2.
    ///   ```[{"T":"error","code":408,"msg":"v2 not enabled"}]```
    ///
    /// * You have attempted to access a data source not available in your 
    ///   subscription package.
    ///   ```[{"T":"error","code":409,"msg":"insufficient subscription"}]```
    ///
    /// * An unexpected error occurred on our end and we are investigating the issue.
    ///   ```[{"T":"error","code":500,"msg":"internal error"}```
    #[serde(rename="error")]
    Error(RealtimeErrorCode),
    /// This variant denotes a **control message** meant to inform you of the
    /// successful completion of the action you requested. For instance, 
    /// upon successfully connecting, you will receive the  welcome message: 
    /// ```json
    /// [{"T":"success","msg":"connected"}]
    /// ```
    ///
    /// Similarly, after connecting with proper credentials you will receive 
    /// another success message: 
    /// ```json
    /// [{"T":"success","msg":"authenticated"}]
    /// ```
    #[serde(rename="success")]
    Success{#[serde(rename="msg")] message: String},
    /// After subscribing or unsubscribing you will receive a message that 
    /// describes your current list of subscriptions.
    /// ```json
    /// [{"T":"subscription","trades":["AAPL"],"quotes":["AMD","CLDR"],"bars":["IBM","AAPL","VOO"]}]
    /// ```
    ///
    /// **Note**: 
    /// You will always receive your entire list of subscriptions, as  
    /// illustrated by the sample communication excerpt below: 
    /// ```json
    /// > {"action": "subscribe", "trades": ["AAPL"], "quotes": ["AMD", "CLDR"], "bars": ["*"]}
    /// < [{"T":"subscription","trades":["AAPL"],"quotes":["AMD","CLDR"],"bars":["*"]}]
    /// > {"action": "unsubscribe", "bars": ["*"]}
    /// > [{"T":"subscription","trades":["AAPL"],"quotes":["AMD","CLDR"],"bars":[]}]
    /// ```
    #[serde(rename="subscription")]
    Subscription(SubscriptionData),

    // --- DATA POINTS --------------------------------------------------------
    #[serde(rename="t")]
    Trade(DataPoint<TradeData>),
    #[serde(rename="q")]
    Quote(DataPoint<QuoteData>),
    #[serde(rename="b")]
    Bar(DataPoint<BarData>),
}

/// A generic datapoint that holds information related to a given symbol
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DataPoint<T> {
    /// The symbol
    #[serde(rename="S")]
    pub symbol: String,
    /// The actual payload
    #[serde(flatten)]
    pub data  : T,
}


/******************************************************************************
 * TESTS **********************************************************************
 ******************************************************************************/

 #[cfg(test)]
 mod tests {
    use crate::realtime::Response;
 
     #[test]
    fn test_deserialize_trade() {
        let txt = r#"{
            "T": "t",
            "i": 96921,
            "S": "AAPL",
            "x": "D",
            "p": 126.55,
            "s": 1,
            "t": "2021-02-22T15:51:44.208Z",
            "c": [
              "@",
              "I"
            ],
            "z": "C"
          }"#;
        let deserialized = serde_json::from_str::<Response>(txt);
        assert!(deserialized.is_ok());
    }
    #[test]
    fn test_deserialize_quote() {
        let txt = r#"{
            "T": "q",
            "S": "AMD",
            "bx": "U",
            "bp": 87.66,
            "bs": 1,
            "ax": "Q",
            "ap": 87.68,
            "as": 4,
            "t": "2021-02-22T15:51:45.335689322Z",
            "c": [
              "R"
            ],
            "z": "C"
          }"#;
          let deserialized = serde_json::from_str::<Response>(txt);
          assert!(deserialized.is_ok());
    }
    #[test]
    fn test_deserialize_bar() {
        let txt = r#"{
            "T": "b",
            "S": "SPY",
            "o": 388.985,
            "h": 389.13,
            "l": 388.975,
            "c": 389.12,
            "v": 49378,
            "t": "2021-02-22T19:15:00Z"
          }"#;
          let deserialized = serde_json::from_str::<Response>(txt);
          assert!(deserialized.is_ok());
    }
 }