//! This module provides an easy access to real time data API offered by Alpaca.
//! 
//! # Real-time data
//! Alpaca Data API v2 provides websocket streaming for trades, quotes and 
//! minute bars. This helps receive the most up to date market information that 
//! could help your trading strategy to act upon certain market movements.
//! 
//! Once a connection is established and you have successfully authenticated 
//! yourself you can subscribe to trades, quotes and minute bars for a 
//! particular symbol or multiple symbols.
//! 
//! ## Subscription plans
//! * **Free plan**:
//!   You can only connect to IEX data source. One concurrent connection is allowed.
//!   Subscription is limited to 30 channels at a time for trades (trades) and 
//!   quotes (quotes). We may support more channels in the future. There is no 
//!   limit for the number of channels with minute bars (bars). Minute bars are 
//!   based on the trades from IEX.
//! 
//! * **Unlimited plan**:
//!   There is no limit for the number of channels at a time for trades, 
//!   quotes and minute bars(trades,quotes and bars). Trades, quotes and mintue 
//!   bars are direct feeds from the CTA (administered by NYSE) and 
//!   UTP (administered by Nasdaq) SIPs.
//! 
//! ## Common behavior
//! To access real-time data use the URL below, substituting `iex` or `sip` to 
//! {source} depending on your subscription.
//! `wss://stream.data.alpaca.markets/v2/{source}`
//! 
//! Attemption to access a data source not available for your subscription will 
//! result in an error during authentication.
//! 
//! ### Message format
//! Every message you receive from the server will be in the format:
//! ```[{"T": "{message_type}", {contents}},...]``` 
//! 
//! Control messages (i.e. where "T" is error, success or subscription) always 
//! arrive in arrays of size one to make their processing easier.
//! 
//! Data points however may arrive in arrays that have a length that is greater 
//! than one. This is to facilitate clients whose connection is not fast enough 
//! to handle data points sent one by one. Our server buffers the outgoing 
//! messages but slow clients may get disconnected if their buffer becomes full.
//! 
//! ### Encoding and compression
//! Messages over the websocket are in encoded as clear text.
//! To reduce bandwidth requirements we have implemented compression as per 
//! RFC-7692. Our SDKs handle this for you so in most cases you won’t have to 
//! implement anything yourself.
//! 
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant 
//! timestamps. These correspond to when a trade was executed or a quote was 
//! generated. As these timestamps are generated by independent market 
//! participants, not the SIP, there is no requirement that the participant 
//! used a synchronized clock or nanosecond resolution. In certain cases due to 
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote 
//! has been reported) will appear before the participant timestamp. 
//! Additionally, though SIP timestamp’s have nanosecond resolution, the 
//! participant timestamps may have broader resolution such as milliseconds or 
//! seconds.

use crate::data::{Source, Action, AuthData, Response, SubscriptionData};
use crate::errors::Error;
use futures::{SinkExt, StreamExt, stream::{SplitSink, SplitStream}};
use tokio::net::TcpStream;
use tokio_tungstenite::{MaybeTlsStream, WebSocketStream, connect_async, tungstenite as tungstenite};
use tungstenite::{Message};

/// The websocket endpoint used to communicate with Alpaca's real time data v2 API
const WSS_ENDPOINT : &str = "wss://stream.data.alpaca.markets/v2/";
type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;

/// This is the object you'll want to create in order to interact with Alpaca's
/// market data api. The object allows both server to client and client to 
/// server communication (these responsibilities can be split for independant/
/// asynchronous processing).
pub struct Client {
    /// The portion of the client devoted to the client to server communication
    write : ClientSender,
    /// The portion of the client devoted to the server to client communication
    read  : ClientReceiver,
}
impl Client {
    /// Creates a client that fetches data from the given source.
    pub async fn new(source: Source) -> Result<Self, Error> {
        // --- Connect to websocket
        let url = format!("{}{}", WSS_ENDPOINT, source);
        let (socket, _rsp) = connect_async(url).await?;
        let (write, read)  = socket.split();
        let write          = ClientSender::new(write);
        let read           = ClientReceiver::new(read);
        //
        Ok(Self {write, read})
    }
    /// Splits the send/receive responsibilities for independant processing
    pub fn split(self) -> (ClientSender, ClientReceiver) {
        (self.write, self.read)
    }
    /// Authenticates the client
    pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
        self.write.authenticate(auth).await
    }
    /// Subscribe for realtime data about certain trades, quotes or bars
    pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.write.subscribe(sub).await
    }
    /// Unsubscribe from realtime data about certain trades, quotes or bars
    pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.write.unsubscribe(sub).await
    }
    /// Returns the stream which is used to receive the responses from the server
    pub fn stream(self) -> impl StreamExt<Item=Response> {
        self.read.stream()
    }
}
/// The portion of the client devoted to the client to server communication
pub struct ClientSender {
    write : SplitSink<WsStream, Message>,
}
impl ClientSender {
    /// Creates a new instance from a given write sink
    pub fn new(write: SplitSink<WsStream, Message>) -> Self {
        Self {write}
    }
    /// Authenticates the client
    pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
        self.action(Action::Authenticate(auth)).await
    }
    /// Subscribe for realtime data about certain trades, quotes or bars
    pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.action(Action::Subscribe(sub)).await
    }
    /// Unsubscribe from realtime data about certain trades, quotes or bars
    pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
        self.action(Action::Unsubscribe(sub)).await
    }
    /// Performs the specified action on the server
    pub async fn action(&mut self, action: Action) -> Result<(), Error> {
        let json = serde_json::to_string(&action)?;
        self.write.send(Message::Text(json)).await?;
        Ok(())
    }
}
/// The portion of the client devoted to the server to client communication.
/// This object is essentially used as a means to obtain an opaquely-types 
/// stream of Responses.
pub struct ClientReceiver {
    read: SplitStream<WsStream>
}
impl ClientReceiver {
    /// Create a new instance from a given message stream
    pub fn new(read: SplitStream<WsStream>) -> Self {
        Self {read}
    }
    /// Returns the stream which is used to receive the responses from the server
    pub fn stream(self) -> impl StreamExt<Item=Response> {
        self.read
        .filter_map(|m| async move {
            if let Ok(Message::Text(t)) = m {
                let data: Vec<Response> = serde_json::from_str(&t).unwrap_or_else(|_| panic!("unexpected message '{}'", t));
                let data = futures::stream::iter(data);
                Some(data)
            } else {
                None
            }
        })
        .flatten()
    }
}