//! This module provides an easy access to real time data API offered by Alpaca.
//!
//! # Real-time data
//! Alpaca Data API v2 provides websocket streaming for trades, quotes and
//! minute bars. This helps receive the most up to date market information that
//! could help your trading strategy to act upon certain market movements.
//!
//! Once a connection is established and you have successfully authenticated
//! yourself you can subscribe to trades, quotes and minute bars for a
//! particular symbol or multiple symbols.
//!
//! ## Subscription plans
//! * **Free plan**:
//!   You can only connect to IEX data source. One concurrent connection is allowed.
//!   Subscription is limited to 30 channels at a time for trades (trades) and
//!   quotes (quotes). We may support more channels in the future. There is no
//!   limit for the number of channels with minute bars (bars). Minute bars are
//!   based on the trades from IEX.
//!
//! * **Unlimited plan**:
//!   There is no limit for the number of channels at a time for trades,
//!   quotes and minute bars(trades,quotes and bars). Trades, quotes and mintue
//!   bars are direct feeds from the CTA (administered by NYSE) and
//!   UTP (administered by Nasdaq) SIPs.
//!
//! ## Common behavior
//! To access real-time data use the URL below, substituting `iex` or `sip` to
//! {source} depending on your subscription.
//! `wss://stream.data.alpaca.markets/v2/{source}`
//!
//! Attemption to access a data source not available for your subscription will
//! result in an error during authentication.
//!
//! ### Message format
//! Every message you receive from the server will be in the format:
//! ```[{"T": "{message_type}", {contents}},...]```
//!
//! Control messages (i.e. where "T" is error, success or subscription) always
//! arrive in arrays of size one to make their processing easier.
//!
//! Data points however may arrive in arrays that have a length that is greater
//! than one. This is to facilitate clients whose connection is not fast enough
//! to handle data points sent one by one. Our server buffers the outgoing
//! messages but slow clients may get disconnected if their buffer becomes full.
//!
//! ### Encoding and compression
//! Messages over the websocket are in encoded as clear text.
//! To reduce bandwidth requirements we have implemented compression as per
//! RFC-7692. Our SDKs handle this for you so in most cases you won’t have to
//! implement anything yourself.
//!
//! ### Timestamps
//! The timestamps for trades, quotes, and bars are based on market participant
//! timestamps. These correspond to when a trade was executed or a quote was
//! generated. As these timestamps are generated by independent market
//! participants, not the SIP, there is no requirement that the participant
//! used a synchronized clock or nanosecond resolution. In certain cases due to
//! unsynchronized clocks, the SIP timestamp (generated after a trade or quote
//! has been reported) will appear before the participant timestamp.
//! Additionally, though SIP timestamp’s have nanosecond resolution, the
//! participant timestamps may have broader resolution such as milliseconds or
//! seconds.

use crate::data::{Action, AuthData, Response, Source, SubscriptionData};
use crate::errors::Error;
use futures::{
  stream::{SplitSink, SplitStream},
  SinkExt, StreamExt,
};
use tokio::net::TcpStream;
use tokio_tungstenite::{connect_async, tungstenite, MaybeTlsStream, WebSocketStream};
use tungstenite::Message;

/// The websocket endpoint used to communicate with Alpaca's real time data v2 API
const WSS_ENDPOINT: &str = "wss://stream.data.alpaca.markets/v2/";
type WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;

/// This is the object you'll want to create in order to interact with Alpaca's
/// market data api. The object allows both server to client and client to
/// server communication (these responsibilities can be split for independant/
/// asynchronous processing).
pub struct Client {
  /// The portion of the client devoted to the client to server communication
  write: ClientSender,
  /// The portion of the client devoted to the server to client communication
  read: ClientReceiver,
}
impl Client {
  /// Creates a client that fetches data from the given source.
  pub async fn new(source: Source) -> Result<Self, Error> {
    // --- Connect to websocket
    let url = format!("{}{}", WSS_ENDPOINT, source);
    let (socket, _rsp) = connect_async(url).await?;
    let (write, read) = socket.split();
    let write = ClientSender::new(write);
    let read = ClientReceiver::new(read);
    //
    Ok(Self { write, read })
  }
  /// Splits the send/receive responsibilities for independant processing
  pub fn split(self) -> (ClientSender, ClientReceiver) {
    (self.write, self.read)
  }
  /// Authenticates the client
  pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
    self.write.authenticate(auth).await
  }
  /// Subscribe for realtime data about certain trades, quotes or bars
  pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
    self.write.subscribe(sub).await
  }
  /// Unsubscribe from realtime data about certain trades, quotes or bars
  pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
    self.write.unsubscribe(sub).await
  }
  /// Returns the stream which is used to receive the responses from the server
  pub fn stream(self) -> impl StreamExt<Item = Response> {
    self.read.stream()
  }
}
/// The portion of the client devoted to the client to server communication
pub struct ClientSender {
  write: SplitSink<WsStream, Message>,
}
impl ClientSender {
  /// Creates a new instance from a given write sink
  pub fn new(write: SplitSink<WsStream, Message>) -> Self {
    Self { write }
  }
  /// Authenticates the client
  pub async fn authenticate(&mut self, auth: AuthData) -> Result<(), Error> {
    self.action(Action::Authenticate(auth)).await
  }
  /// Subscribe for realtime data about certain trades, quotes or bars
  pub async fn subscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
    self.action(Action::Subscribe(sub)).await
  }
  /// Unsubscribe from realtime data about certain trades, quotes or bars
  pub async fn unsubscribe(&mut self, sub: SubscriptionData) -> Result<(), Error> {
    self.action(Action::Unsubscribe(sub)).await
  }
  /// Performs the specified action on the server
  pub async fn action(&mut self, action: Action) -> Result<(), Error> {
    let json = serde_json::to_string(&action)?;
    self.write.send(Message::Text(json)).await?;
    Ok(())
  }
}
/// The portion of the client devoted to the server to client communication.
/// This object is essentially used as a means to obtain an opaquely-types
/// stream of Responses.
pub struct ClientReceiver {
  read: SplitStream<WsStream>,
}
impl ClientReceiver {
  /// Create a new instance from a given message stream
  pub fn new(read: SplitStream<WsStream>) -> Self {
    Self { read }
  }
  /// Returns the stream which is used to receive the responses from the server
  pub fn stream(self) -> impl StreamExt<Item = Response> {
    self
      .read
      .filter_map(|m| async move {
        if let Ok(Message::Text(t)) = m {
          let data: Vec<Response> =
            serde_json::from_str(&t).unwrap_or_else(|_| panic!("unexpected message '{}'", t));
          let data = futures::stream::iter(data);
          Some(data)
        } else {
          None
        }
      })
      .flatten()
  }
}
